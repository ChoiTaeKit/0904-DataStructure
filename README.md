# 최 태웅 (Choi Taeung)
### 202530235

# 25/11/13 강의
## 강의 진도 안내
- 7장: 문자열 검색 알고리즘
    - C언어를 이용해서 문자열 중에 원하는 문자열을 찾는 내용으로 자료구조와 연관성 적음.
    - 8장 생략
    - 검색과 관련해서 트리에서, 6장 정렬에서 검색의 기본은 학습함.

- 8장: 리스트 전형적인 자료 구조
    - 8-1: 리스트의 개념 설명
    - 8-2~4: 리스트 실기 프로그래밍.

- 9장: 트리 전형적인 자료 구조(개념 중요)

- 10장: ~~자료구조 응용이므로 생략.~~


## 선형 리스트
* 리스트(list)
    * 데이터를 **순서대로 나열**해 놓은 자료구조
    * 가장 단순한 구조를 가진 리시트를 선형 리스트 또는 연결 리스트라고 함.
    * 각 데이터의 연결 관계를 '이야기 전달하기 게임'에 비유할 수 있다.
    * 즉, 한 사람을 건너뛰어 이야기를 전달할 수 없음.

* 노드(node)
    * 리스트의 각 요소
    * 각각의 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 있음
    * 처음과 끝에 있는 노드는 특벼리 각각 머리 노드 , 꼬리 노드라고 함.
    * 하나의 노드에 대해 바로 앞에 있는 노드를 앞쪽 노드(predecessor node), 바로 뒤에 있는 노드를 다음 노드(successor node)라고 함.

* 배열로 선형 리스트 만들기
    * 다음 노드 꺼내기
        - 배열의 각 요소에는 연락할 순서대로 데이터가 저장
        - 전화를 걸기 위해 필요한 '다음 노드 꺼내기'는 1만큼 큰 인덱스를 갖는 요소에 접근.

    * 노드의 삽입과 삭제
        - 회원번호 55인 회원이 새로가입했고, 이 회원의 정보를 회원번호 12, 33 사이에 삽입할려면 삽입 요소 다음의 모든 요소를 하나씩 뒤로 밀어야 함.
        - 삭제하는 경우도 모든 요소를 뒤로 밀거나 앞으로 당김.
        - 이런 작업이 필요하므로 배열로 구현한 선형 리스트는 쌓이는 데이터의 크기를 미리 알아내야함.
        - 데이터의 삽입, 삭제에 따라 데이터를 모두 옮겨야 하기 때문에 ***효율이 나쁨***.

* 포인터로 연결 리스트 만들기
    * 노드용 구조체(Node)
        - 노드용 객체를, 연결 리스트에 데이터를 삽입할 때 만들고 삭제할 때 없애면, 데이터를 밀고 당기는 문제를 해결 할 수 있음.
        - 노드용 구조체 Node는 data와 next로 구성함.
            1. data ...데이터(Member)형
            2. next ...다음 노드에 대한 포인터(자기 자신과 같은 구조체형을 가리키는 포인터형.)\
        - 이와 같이 자기 자신과 같은 자료형의 객체를 가리키는 데이터가 내부에 포함.
        - 이러한 자료구조를 자기참조(self-referential)형 이라고 함.
    
    * 연결 리스트를 관리하는 구조체 List
        - 노드용 구조체 Node를 사용한 연결 리스트를 나타낸 것
        - List는 두 멤버로 구성, 모두 Node에 대한 포인터 자료형을 가짐.
            1. head는 연결 리스트의 머리 노드를 가리키는 머리 포인터
            2. cmt는 현재 선택한 노드를 가리키는 선택 포인터
        - '검색'한 노드를 선택하고 '삭제'하는 용도로 사용.
        - 연결 리스트를 관리하는 구조체 List는 2개의 포인터만 가짐.

        * cmt: 현재 선택한 노드를 가리키는 포인터(커서)
    
    * 꼬리 노드를 삭제하는 RemoveRear 함수
        - 리스트에 노드가 1개뿐인지(list -> next == NULL)아니면 2개 이상인지에 따라 서로 다른 작업을 수행
            1. 리스트에 노드가 1개만 있는 경위 머리 노드를 삭제하는 것과 같으므로 RemoveFront 함수로 처리
            2. 리스트에 노드가 2개 이상있는 경우.

* 커서로 연결 리스트 만들기
    * 커서를 사용한 연결 리스트
        - 프로그램 실행 중에 데이터의 개수가 크게 바뀌지 않고 데이터 개수의 최댓값을 미리 알 수 있다고 가정하면 배열을 사용해 효율적으로 연결리스트를 운용할 수 있음

        - 배열의 커서에 해당하는 값은 다음 노드에 대한 포인터가 아닌 다음 노드가 들어 있는 요소의 인덱스에 대한 값이다.
            * 여기서 포인터 역할을 하는 인덱스를 커서(cursor)라고 함.

## 프리 리스트 구현하기
* 프리 리스트(free list)
    - 삭제한 레코드를 관리하기 위해 사용하는 자료구조.
    - 삭제한 여러 레코드를 관리하면 앞에서 발생한 '사용하지 않는 빈 배열'의 문제를 해결할 수 있음.
    - 프리 리스트는 앞에서 다룬 '커서로 연결 리스트 만들기'와 같은..

## 원형 리스트 알아보기
* 원형 리스트(circular list)
    - 선형 리스트의 꼬리 노드가 머리 노드를 가리킴
    - 고리 모양으로 나열된 데이터를 저장할 떄 알맞은 자료구조
    - 원형 리스트와 선형 리스트의 차이점은 꼬리 노드의 다음 노드를 가리키는 포인터가 널(NULL)이 아니라 머리 노드의 포인터값이라는 점
    - 원형 리스트는 선형 리스트에서 사용했던 것과 같은 자료형을 사용할 수 있음.

* 빈 원형 리스트를 판단하는 방법
    - 노드가 없는(비어있는) 원형 리스트인지 판단하려면 오른쪽 식을 사용

* 노드가 1개인 원형 리스트를 판단하는 방법
    - 노드가 1개라면 머리 노드의 다음 포인터는 자기 자신인 머리 노드를 가리킴

* 포인터가 머리 노드를 가리키는지 판단하는 방법
    - Node형 변수 p가 리스트에 있는 어떤 노드를 가리키는 경우 p가 가리키고 있는 노드가 원형 리스트의 머리 노드인지 판단하려면 오른쪽 식을 사용

* 포인터가 꼬리 노드를 가리키는지 판단하는 방법

## 이중 연결 리스트 알아보기
* 이중 연결 리스트(doubly linked list)
    - 선형 리스트의 가자 큰 단점은 다음 노드는 찾기 쉽지만 앞쪽의 노드를 찾으려면 비용이 든다는 점을 개선한 자료구조
    - 각 노드에는 다음 노드에 대한 포인터와 앞쪽의 노드에 대한 포인터가 주어짐.

## 원형 이중 연결 리스트 알아보기
* 원형 이중 연결 리스트(circular doubly linked list)
    - 앞에서 공부한 두 가지의 개념을 합함.


# 25/11/06 강의
## 번외 - 오프라인 행사 관련 후기.


## 퀵 정렬 - 10/31 강의에서 이어짐.

### qsort 함수 정렬
* qsort 함수
    * bsearch 함수와 마찬가지로 int형이나 double형 등의 배열뿐만 아니라 구조체형 배열 등 모든 자료형의 배열에 적용.
    * 전달하는

## 병합 정렬

### 정렬을 마친 배열 병합하기 
* 병합(merge)
    * 각 배열에서 선택한 요소의 값을 비교하여 작은 값의 요소를 꺼내 새로운 배열에 넣는 작업 을 반복하여 정렬을 마치는 배열을 만듦.

    * 요소의 개수가 na개인 배열 a와 요소의 개수가 nb개인 배열 b를 병합하여 배열 c에 저장

    * 이 함수에서는 세 개의 배열 a,b,c를 동시에 스캔
        - 이때 각 배열이 선택한 요소의 인덱스는 pa, pb, pc
        - 이 인덱스를 저장한 변수를 커서라고 함.
    
    * 처음에는 첫 요소를 선택하므로 커서를 모두 0으로 초기화

### 병합 정렬 하기
* 병합 정렬(merge sort)
    * 정렬을 마친 배열의 병합을 응용하여 분할 정복법에 따라 정렬하는 알고리즘
    
    * 먼저 배열을 앞부분과 뒷부분으로 나눔
    
    * 나눈 두 배열을 각각 정렬 및 병합하면 배열 모두 정렬 가능.

    

* 알고리즘
    * 배열의 요소 개수가 2개 이상인 경우
        1. 배열의 앞부분을 병합 정렬로 정렬
        2. 배열의 뒷부분을 병합 정렬로 정렬
        3. 배열의 앞부분과 뒷부분을 병합.

* 시간 복잡도
    - 배열 병합의 시간 복잡도는 O(n)이다.


## 힙 정렬
### 힙 정의하기

* 힙(heap)
    - ***부모의 값이 자식의 값보다 항상 크다*** 는 조건을 만족하는 **완전 이진트리**.
    
    - 부모와 자식 관계는 항상 '**부모의 값 >= 자식의 값**'
        - 힙의 가장 위쪽에 있는 **루트가 가장 큰 값**이 됨.
    
    - **형제 사이의 대소 관계는 일정하지 않음**.

* 힙 정렬
    - 가장 큰값이 루트에 위치 하는 특징을 이용하는 정렬 알고리즘.
        1. 힙에서 가장 큰값인 루트를 꺼냄
        2. 루트 이외의 부분을 힙으로 전환
    
    - 힙 정렬은 선택 정렬을 응용함.

* 루트를 없애고 힙 상태 유지.
    - 루트를 없앤 다음 다시 힙을 만들기 위해 요소를 알맞은 위치로 내려보내야하는 순서는 아래와 같다.
        1. 루트 꺼냄.
        2. 마지막 요소를 루트로 이동.
        3. 자기보다 큰 값을 가지는 자식 요소와 자리를 바꾸며 아래쪽으로 내려가는 작업을 반복
            - 이때 자식의 값이 작거나 잎에 다다르면 작업이 종료됨.

* 트리의 종류와 힙
    - 최대힙은 부모 노드가 자식 노드보다 큰 경우를 말함.
        - 최소힙은 그와 반대이다.

* 추가로...
    - 우선순위 큐를 위해 고안된 완전 이진트리
    - 반정렬 상태 유지.


## 도수 정렬

### 도수 정렬하기

* 도수 정렬
    - 지금까지의 정렬 알고리즘은 두 요소의 키값을 비교해야했음.
    - 도수 정렬은 요소를 비교할 필요가 없다는 특징이 있음

* 도수 정렬 알고리즘
    - 도수분포표 만들기
    - 누적도수분포표 만들기
    - 목적 배열 만들기
    - 배열 복사하기

* 도수(계수) 정렬
    - 데이터의 대소 관게를..


# 25/10/31 보강

## 단순 선택 정렬 - straight selection sort
* 아직 정렬하지 않은 부분에서 값이 가장 작은 요소를 선택하고 아직 정렬하지 않은 부분의 첫 번째 요소와 교환

* 교환 과정
    1. 아직 정렬하지 않은 부분에서 가장 작은 키의 값(a[min])을 선택
    2. a[min]과 아직 정렬하지 않은 부분의 첫 번째 요소를 교환

    - 이 과정을 n - 1회 반복하면 됨.

* 실습 6-4
    - 단순 선택 정렬을 수행하는 함수
    - 단순 선택 정렬 알고리즘의 요솟값을 비교하는 횟수는 n²-n / 2회
    - 서로 떨어져 있는 요소를 교환하는 것이기 때문에 불안정적.

## 단순 삽입 정렬
* straight insertion sort
    - 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 '삽입하는' 작업을 반복하는 정렬알고리즘.
    - 아직 정렬되지 않는 부분의 첫 번째 요소를 정렬된 부분의 알맞은 위치에 삽입
    - 아래의 두 조건 중 하나를 만족할 때 까지 j를 1씩 감소하면서 대입하는 작업을 반복
        1. 정렬된 열위 왼쪽 끝에 도달
        2. tmp보다 작거나 같은 key를 갖는 항목 a[j - 1]을 발견
    
    - 드모르간 법칙 적용으로 아래의 두 조건이 모두 성립할 때까지 반복
        1. j가 0보다 큼
        2. a[j - 1]값이 tmp보다 큼.

* 장점
    - 정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라짐.
* 단점
    - 삽입할 위치가 멀리 떨어져 있으면 이동(대입)해야 하는 횟수가 많아짐.

##### 단순 정렬의 시간 복잡도 - O(n²)으로 효율이 매우 떨어짐.

## 셀 정렬
* shell sort
    - 단순 삽입 정렬의 장점은 살리고 단점을 보완한 정렬 알고리즘
    - 정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행
    - 그 그룹을 합치면서 정렬을 반복하여 요소의 이동 횟수를 줄이는 방법
* 4-정렬
    - 4칸만큼 떨어진 요소를 모아 그룹을 4개로 나누어 정렬하는 방법
    - 아직 정렬을 마친 상태는 아니지만 정렬을 마친 상태에 가까워짐.
* 2-정렬
    - 2칸만큼 떨어진 요소를 모아 두 그룹({7,3,8,4},{1,2,6,5})으로 나눔.
    - 정렬을 마치고 나면 각각의 그룹은({3,4,7,8}, {1,2,5,6})으로 정렬됨.
* h-정렬
    - 셸 정렬 과정에소 수행하는 각각의 정렬
        1. 2개 요소에 대해 '4-정렬'(4개의 그룹) 
        2. 4개 요소에 대해 '2-정렬'(2개의 그룹)
        3. 8개 요소에 대해 '1-정렬'(1개의 그룹)
    - 증분값(h값)의 선택
        - h값은 n부터 감소하여 마지막에 1이 되면 됨
        - 두 그룹은 서로 섞이지 않음.
        - 섞이지 않으면 c를 합쳤을 때 다시 처음 단계인 a와 동일한 상태가 됨.
        - 그러면 다시 a의 학생을 정렬하는 것과 같아서 그룹을 나누었음에도 정렬 알고리즘이 충분히 작동하지 않음.
        - h값이 서로 배수가 되지 않도록 해야 요소가 충분히 섞여 효율적인 정렬을 기대할 수 있음
        - 아래 수열을 거꾸로 살펴보면 1부터 시작하여 3배한 값에 1을 더하는 수열.
            - ` h = ..., -> 121 -> 40 -> 13 -> 4 -> 1 `

## 퀵 정렬
* quick sort
    - 일반적으로 사용되고 있는 아주 빠른 정렬 알고리즘
    - 그림 6-19 참조.
        - 학생 수가 8명인 그룹을 키 순서대로 정렬한 모습.
            1. 먼저 어느 한 사람의 키를 선택
            2. 키가 168cm인 학생 A를 선택할 경우 그 학생을 기준으로 학생 A의 키보다 작은 사람의 그룹과 큰 사람의 그룹으로 나눔
            3. 이때 이 학생 A의 키를(그룹을 나누는 기준) 피벗(pivot)이라고 함.
            4. 각 그룹에 대해 피벗 설정과 그룹 나눔을 반복하며 모든 그룹이 1명이 되면 정렬을 마침.

## 배열을 두 그룹으로 나누기
* 배열을 두 그룹으로 나누기
    * 그룹을 나누려면 피벗 이하의 요소를 배열 왼쪽으로, 이상의 요소를 배열 오른쪽으로 옮겨야 함.
        1. a[pl] >= x가 성립하는 요소를 찾을 때까지 pl을 오른쪽으로 옮김.
        2. a[pr] <= x가 성립하는 요소를 찾을 때까지 pr을 왼쪽으로 옮김.

    * pl지점은 피벗값 이상의 요소가 있는 지점, pr지점은 피벗 값 이하의 요소가 있는 지점.
    * pl과 pr이 교차하면 그룹을 나누는 과정이 끝나고 배열은 아래처럼 두 그룹으로 나누어짐.
        - 피벗 이하의 그룹: `a[0], ..., a[pl-1]`
        - 피벗 이상의 그룹: `a[pr+1], ..., a[n-1]`

* 피벗과 같은 값을 가지는 그룹
    - 그룹을 나누는 작업이 끝난 다음 pl > pr + 1인 경우에는 다음과 같은 그룹이 생길 수 있음.
        - 피벗과 일치하는 값을 가지는 그룹: `a[pr+1], ..., a[pl-1]`
    - b,c,d 왼쪽 커서, 오른쪽 커서가 피벗 이상, 피벗 이하의 요소를 찾아 멈춘 단계
    - d pl,pr이 동일한 요소인 a[4] 위에 있고 이때 동일한 요소인 a[4]와 a[4]를 교환
    - 동일한 요소를 교환하는 시도가 의미 없어 보이나, 이 시도는 아무리 많아야 1회이므로 괜찮다.
    - e 계속 스캔하면 pl, pr이 교차하면서 그룹을 나누는 과정을 마침.

# 25/10/30 강의

## 스택(stack) - 1
* 데이터를 일시적으로 저장하기 위해 사용하는 자료구조.
* 입출력 순서는 후입선출(LIFO, Last In First Out)방식
    - 즉, 가장 나중에 넣은 데이터를 가장 먼저 꺼냄

* 푸시(push): 스택에 데이터를 넣는 작업
* 팝(pop): 데이터를 꺼내는 작업
* 꼭대기(top): 푸시, 팝을 하는 위치
    - 테이블에 겹겹이 쌓은 접시처럼 데이터를 넣는 작업도 꺼내는 작업도 위쪽부터 수행
* 바닥(bottom): 스택의 가장 밑바닥 부분

## 스택 - 2
* 구현 예시
    - 함수를 호출하고 실행할 때 프로그램 내부에서는 스택을 사용
    - 가장 먼저 main함수를 실행, z 함수를 호출함.
    - 호출된 함수 z는 x함수와 y함수를 순서대로 호출.
    - 함수를 호출할 때는 **push**, 함수가 실행 및 종료하고 호출한 원래의 함수로 리턴할때는 종료할 함수를 **pop**함.

    - main -> z -> x의 순서대로 함수 호출.
        - 이때, 스택의 상태는 호출하는 함수의 역순으로 겹겹이 쌓여 있어, 함수 호출이 ***계층 구조***로 이루어짐.
        - 이 상태에서 x함수의 실행이 종료되면 x함수만 **pop**함.

## 스택 만들기 - 1
* 스택 구조체 IntStack
    - 스택으로 사용할 배열을 가라키는 포인터 stk
        - index가 0인 요소를 스택의 바닥(bottom)이라 함.
        - 배열의 메모리 공간 할당은 Initialize 함수로 생성
    - 스택의 최대 용량 max
        - 배열 stk의 요소 개수와 같음
    - 스택 포인터 ptr
        - 스택에 쌓여 있는 데이터의 개수를 나타냄
        - 스택이 비어 있으면 ptr의 값은 0, 가득 차 있으면 max.

## 큐
* 데이터를 일시적으로 쌓아 두기 위한 자료 구조
    - 선입선출 방식.(FIFO)

### 큐 예시
* a 배열의 프런트부터 4개(19, 22, 37, 53)의 데이터가 들어가 있는 모습
* b 24 인큐
    - 리어의 데이터가 저장된 que[3]의 다음 요소 que[4]에 24를 저장
    - 이 처리의 복잡도는 **O(1)**이고 적은 비용으로 구현 가능.
* c 19 디큐
    - 

### 링 버퍼
* 배열의 처음이 끝과 연결되었다고 보는 자료구조
* 프런트: 논리적인 맨 처음 요소의 인덱스
* 리어: 논리적인 맨 끝 요소의 하나 뒤의 인덱스(다음 요소를 인큐할 위치를 미리 지정)
* 변수 프런트와 리어의 값은 인큐와 디큐를 수행함에 따라 변화, 배열 요소를 앞쪽으로 옮기지 않는 큐를 구현할 수 있음.
* 처리의 복잡도는 **O(1)**.

## 정렬 - sorting
* 정렬
    * 핵심 항목(key)의 대소 관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업
    * 키값이 작은 데이터를 앞쪽에 놓으면 오름차순 정렬, 반대로 놓으면 내림차순 정렬.

* 정렬 알고리즘의 안정성
    - 같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지되는 것.

* 정렬 알고리즘의 핵심 요소
    - 교환, 선택, 삽입

### 버블 정렬
* 패스(pass)
    - 이웃한 요소를 비교, 교환하는 작업을 첫 번째 요소까지 계속.
    - 요소의 개수가 n개인 배열에서 n-1 회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동함
    - 이런 일련의 과정(비교, 교환 작업)을 패스라고 함.

* 패스 수행 횟수
    - 두 번째 패스의 비교 횟수는 첫 번째 패스보다 1회적은 n-2회
        - 그 이유는 패스를 1회 수행할 때마다 정렬할 요소가 하나씩 줄어들기 때문.
    
    - 패스를 k회 수행하면 앞쪽의 요소 k개가 정렬
    - 모든 정렬이 끝나려면 n-1회의 패스가 수행되어야함.

* 알고리즘 개선
    - 어떤 시점 이후에 교환이 수행되지 않는다면 그보다 앞쪽의 요소는 이미 정렬 마친 상태라고 생각하면됨.
    - 이미 배열이 정렬을 마친 상태라면 그 이후의 패스는 요소 교환을 하지 않음
    - 즉, 어떤 패스에서 

# 25/10/23 강의

## 검색과 키, 배열 검색

* 주소록 검색
    - 특정 항목에 주목함.
    - 주목하는 항목을 키(key)라고 함.
        * 예시
        1. 국적이 한국인 사람을 찾습니다.
            - 키값과 일치하게 지정 (한국)
        2. 나이가 21세 이상 27세 미만인 사람을 찾습니다.
            - 키값의 구간을 지정 (21세 이상 27세 미만)
        3. 어떤 낱말과 발음이 가장 비슷한 이름의 사람을 찾습니다.
            - 키값과 비슷하도록 지정 (발음이 가장 비슷한 이름)

    - 단순한 정수 값이면 데이터 값을 키 값이라고 생각하나, 키는 데이터의 '일부'다.
    - 하나만 지정, 논리곱이나 논리합을 사용하여 복합해서 지정함.

* 배열 검색 - 공통: 빠른 검색 실행함.
    - 선형 검색 : 무작위로 늘어놓은 데이터 모임
    - 이진 검색 : 일정한 규칙으로 늘어놓은 데이터 모임
    - 해시법 : 추가, 삭제가 자주 일어나는 데이터 모임
        - 체인법 : 같은 해시값의 데이터를 선형 리스트로 연결하는 방법
        - 오픈 주소법: 데이터를 위한 해시값이 충돌할 때 재해시하는 방법

### 선형 검색
* 선형 검색 다루기(1)
    * **선형 검색(linear search)** 또는 **순차 검색(sequential search)**
        - 요소가 **직선 모양으로 늘어선 배열**에서의 검색은 원하는 키값을 갖는 요소를 만날 때까지 **맨 앞부터 순서대로 요소를 검색**.

    * 선형 검색에서 배열 검색의 종료 조건
        1. 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우 **(검색 실패)**
        2. 검색할 값과 같은 요소를 발견한 경우 **(검색 성공)**
        - 배열 요소의 개수가 n개일 때 1,2 조건을 판단하는 횟수는 **평균 n/2 회**다.

* 선형 검색 다루기(2)
    * 요소 개수가 n인 배열 a에서 값이 key인 요소를 검색하는 코드
        1. 배열을 검색할 때 배열 요소의 인덱스를 가리키는 변수는 i
        2. i는 0으로 초기화하고, 요소를 하나 검색할 때마다 while문이 제어하는 루프 본문의 끝에서 증가
        3. 배열 검색 종료 조건 중 어느 하나라도 성립한 경우에는 while 문을 빠져나감.

        ```C
            int i = 0;
            while (1){
                if(i == n)
                    return -1;  //검색실패 
                if(a[i] == key)
                    return 1;   //검색성공
                i++
            }
        ```

* 선형 검색 다루기(3)
    - search 함수는 배열 a의 처음부터 끝까지 n개의 요소를 대상으로 값이 key인 요소를 선형 검색
    - 반환값은 발견한 요소의 인덱스
    - 만약 값이 key인 요소가 여러 개 존재한다면 반환값은 검색 과정에서 처음 발견한 요소의 인덱스
    - 값이 key인 요소가 존재하지 않으면 -1 반환.

    ```C
        int main(void) 
        { 
            int nx, ky;
            puts("선형 검색");
            printf("요소 개수: ");
            scanf("%d",&nx);
            int *x= calloc(nx, sizeof(int)); // 요소의 개수가 nx인 int형 배열 x를 생성 
            for(int i = 0; i < nx; i++) { 
                printf("x[%d]:",i); 
                scanf("%d",&x[i]); 
            } 
            printf("검색값: ");
            scanf("%d",&ky);
            int idx = search(x, nx, ky);// 배열 x의 값이 ky인 요소를 선형 검색
            if(idx ==- 1) 
                puts("검색에 실패했습니다.");
            else 
                printf("%d(은)는 x[%d]에 있습니다. \n", ky, idx);
            free(x); // 배열 x를 해제

            return 0;
        }
    ```

* 선형 검색 다루기(4,5)
    - 선형 검색 구현 (search1.c)

### 보초법검색
* 보초법(sentinel method)
    - 종료 조건을 검사하는 비용을 반으로 줄이는 방법

* 보초법을 이용한 선형 검색
    - 배열의 요소 a[0] ~ a[6]은 원래 데이터
    - 맨 끝 요소 a[7]은 검색하기 전에 준비하는 보초
    - 원하는 값이 원래의 데이터에 존재하지 않아도 보초인 a[7]까지 검색하면 종료조건 2가 성립.
    - 이렇게 하면 원하는 키값을 찾지 못했을 때 종료 조건 1이 없어도 됨.
    - 보초는 반복문에서 종료판단 횟수를 2회에서 1회로 줄이는 역할.

    * **참고** 선형 검색에서 배열 검색의 종료 조건
        1. 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우
        2. 검색할 값과 같은 요소를 발견한 경우.

* 보초법 검색 다루기

### 이진 검색
* 이진 검색
    - 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘
* 이진 검색에서 배열 검색의 종료 조건
    1. 중앙 요소와 key가 일치하는 경우(검색 성공)
    2. 검색 범위가 더 이상 없는 경우(검색 실패)
* 검색에 필요한 비교횟수
    - 검색을 반복할 떄마다 검색 범위가 절반이 되므로 검색에 필요한 비교 횟수의 평균값은 log n
    - 성공한 경우에는 대략 log n - 1회
    - 실패한 경우는 log(n+1)회

### 복잡도
* 복잡도(complexity)
    - 프로그램의 실행 속도는 프로그램이 동작하는 HW나 컴파일러 등의 조건에 따라 달라짐
    - 알고리즘의 성능을 객관적으로 평가하는 기준

* 복잡도의 두 가지 요소
    1. 시간 복잡도: 실행에 필요한 시간을 평가한 것
    2. 공간 복잡도: 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것

* 시간 복잡도와 공간 복잡도
    - 앞 장에서 배운 '소수'를 찾는 프로그램은 알고리즘을 선택할 때 두 복잡도(시간, 공간)의 균형을 생각할 필요성이 있음.

* 선형 검색의 시간 복잡도
    - O(f(n)) + O(g(n)) = O(max(f(n), g(n)))
        - 일반적으로 O(f(n))과 O(g(n))의 복잡도 계산하는 방법.

### 정렬된 배열에서 검색하는 bsearch 함수 알아보기
* bsearch
    - C언어 표준 라이브러리는 다양한 요소의 자료형을 가진 배열에서도 검색 가능한 bsearch 함수를 제공
    - 이진 검색에서 따왔지만, 내부적으로 항상 이진 검색 알고리즘을 사용하지는 않음.

    * 특징
        1. 검색 대상의 배열은 항상 정렬되어 있어야 함
        2. 검색하는 값과 같은 요소가 여러 개 존재하는 경우, 항상 가장 앞쪽에 있는 요소를 찾아내는건 아님.
# 25/10/16(중간고사)

# 25/10/2 강의
## 배열 요소를 역순으로 정리(1)
- 배열 요소를 역순으로 정렬.
    - 왼쪽 요소의 인덱스 ... i
    - 오른쪽 요소의 인덱스 ... n - i - 1

* 두 값의 교환
    - 1: t = x; x값을 t에 보관
    - 2: x = y; y값을 x에 대입
    - 3: y = t; t에 보관한 처음 x값을 y에 대입

## 배열 요소를 역순으로 정리(2)

- 실습 2-7(1)
- swap은 'type형 변수 x, y'의 값을 교환하는 함수 형식의 매크로
- 함수 형식 매크로는 프로그램을 컴파일하는 과정에서 그대로 치환
- ary_reverse 함수는 함수 형식 매크로 swap을 n/2회 호출하여 배열의 요소를 역순으로 정렬. 


## 배열 요소의 최대값 구하기(1)
1. rand함수, srand 함수, time 함수의 선언이 들어 있는 헤더를 포함
2. 난수의 seed(씨앗)를 초기화하기 위해 srand 함수를 호출
3. 난수를 생성하기 위해 rand 함수를 호출

## 기수 변환하기(1)
* 정수 값을 임의의 기수(cardinal number)로 변환하는 알고리즘
    - 10진수 정수를 n진수 정수로 변환할려면
    - 정수를 n으로 나눈 나머지를 구하는 동시에 그 몫에 대해 나눗셈을 반복
    - 이 과정을 몫이 0이 될 때까지 반복
    - 이 과정에서 구한 나머지를 거꾸로 늘어 놓은 숫자가 기수로 변환한 숫자
    - 기수가 10단위를 넘는 경우 0 ~ 9에 이어지는 숫자로 알파벳 문자인 A, B, ...를 사용
    - 16진수는 아래 16개의 문자로 표현되는 수(0,1,2,3,4,5,6,7,8,9,**A,B,C,D,E,F**)

## 기수 변환하기(2)
* 실습 2-8[A](1)
    - 기수 변환을 수행하는 프로그램
    - card_convr함수는 정수 x를 n진수로 변환한 숫자 문자의 정렬을 char형 배열 d에 저장 및 그 자릿수(배열에 저장한 문자 수)를 반환하는 함수.
    - char형의 배열 dchar는 "0123456789ABCDFEFGHIJKLMNOPQRSTUVWXYZ"

## 소수 나열하기(1)
* 소수(prime number)

## 다차원 배열(multidimensional array)
* 배열을 요소로 하는 배열
    * 배열을 자료형으로 하면 2차원 배열이고, 2차원 배열을 자료형으로 하면 3차원 배열

- 1차원 배열: 지금까지 배운 '단일 자료형을 가지는 배열'
- 2차원 배열의 도출
    1. [a] int형 .. int 자료형
    2. [b] int[3]형 ... int를 자료형으로 하는 단일 요소가 3개인 배열
    3. [c] int[4][3]형 ... int를 자료형으로 하는 단일 요소가 3개인 배열을 자형으로 하는 요소 개수가 4개인 배열.

## 구조체(structure)
- 임의의 자료형의 요소를 조합하여 다시 만든 자료구조

* 구조체형과 멤버의 접근
    1. 구조체 선언
        - 구조체에 붙는 이름인 xyz를 구조체 태그라고 함.
        - 구조체를 구성하는 요소를 구조체 멤버라고 함.
    2. 구조체형을 갖는 객체 정의
        - struct xyz 형을 갖는 객체 a를 정의
        - 구조체의 객체 안 멤버는, 연산자를 사용하여 접근
    3. 포인터가 객체를 가리키도록 선언
        - p가 구조체형 객체에 대한 포인터일 때 p가 가리키는 객체의 멤버 x에 접근하는 형식은 연산자를 사용함.

- 구조체 동의어 정의
    1. 구조체는 태그 이름 xyz만으로 구조체 자료형의 이름으로 지정할 수 없음.
    2. 구조체 자료형의 이름은 struct xyz처럼 두 단어로 구성해야함.
    3. typedef 선언을 사용해 짧은 이름으로 다시 만들어 사용할 수 있음.
    4. 이제 하나의 단어 xyz만으로 구조체 자료형의 이름을 나타낼 수 있음.
    5. 이렇게 하면 변수 a와 포인터 p를 간단하게 선언하고 정의할 수 있음.
    

# 25/9/25 강의

## 배열(array)

* 배열은 같은 자료형의 변수로 이루어진 요소가 모여 직선 모양으로 줄지어 있는 자료구조.
* 네모 칸 안에 쓰인 숫자나 문자가 요소 값이고, 네모 칸의 왼쪽 또는 위쪽에 쓰인 작은 숫자가 인덱스 값.(index)

## 배열 이름[인덱스]
* 배열의 개별 요소에 접근할 때 인덱스 식(subscript expression)을 사용.
* 배열의 요소 값을 초기화하며, 배열을 선언하는 프로그램.
* 각 요소를 처음부터 순서대로 쉼표(,)로 구분하여 줄지어 놓고 {}로 둘러쌈으로써 배열 요소 초기화.
* sizeof(a)로 전체 배열이 할당된 메모리 크기를 구하고, sizeof(a[0])로 첫 번째 요소가 할당된 메모리 크기를 구한 다음, 전체 배열 크기를 첫 요소 크기로 나눈 몫이 요소 개수가 됨.

### 수식
`sizeof(배열명)` / `sizeof(자료형)`
* 자료형에는 int, char, double 등을 사용.

### 메모리 할당 
* calloc, malloc 함수는 힙(heap)이라는 특별한 '빈 공간(free space)'에 기억 장소 확보함.
    * 사용 할 떄는 헤더 `#include <stdlib.h>` 사용

* calloc(clear and allocation): 메모리를 할당하고 0으로 초기화.
1.일반적으로 메모리 1개를 설정하기 위해서 calloc 함수를 사용하지 않음.
2.배열처럼 여러 개 요소를 할당, 초기값을 0으로 맞추고 싶을 때 유용.
3.배열은 정적 메모리 할당이고, calloc 함수는 동적 메모리 할당이다.
-> 배열은 컴파일할 때 크기가 정해져야 하지만, 런타임에 원하는 크기만큼 할당할 수 있음.
-> 즉, 가변크기 할당 가능.

* malloc(memory allocation): 메모리를 할당만 하고 초기화는 X. (가비지)
* heap : 완전 이진 트리의 한 종류로 최대힙과 최소힙이 존재.

#### 메모리 해제
* 확보한 메모리가 불필요하면 그 공간을 해제해야 하는데 이를 위해 제공되는 함수가 free함수다.
    * 프로그램을 실행하는 도중에도 원하는 시점에 제거할 수 있음.
* `free()`는 *동적으로* **할당된 메모리를 해제하는 역할**을 하는 것.

## 스택 메모리
##### 스택(stack) 메모리는 자료구조의 스택 (FIFO)과는 다름.
- 스택 메모리는 메모리 관리 방식이지 메모리 접근 방식이 아님.
- 그러므로 FIFO를 따르는 것이 아니라 index를 통해 입출력을 함.

## 배열 요소의 최댓값 구하기 - maxof()
- maxof는 내장 함수가 아님.
- 주사(traverse) : 배열의 요소를 하나씩 차례로 살펴보는 과정.

# 25/9/18 강의
## 반복

* 반복 구조(reptition structure) 또는 루프(loop)
    * 어떤 조건이 성립하는 동안 처리(프로그램 명령문 또는 명령어의 집합)를 반복해 실행하는 것.

* While(제어식) 명령문
    * 반복의 대상이 되는 '명령문'을 문법적으로는 '루프 본문' 이라고 함.

* do-while(제어식) 사전 판단 반복
    * **실행 전에 계속 반복 할지**를 판단합니다.
    * 제어식의 평가 값이 0(false)이 아니면 프로그램 명령문을 반복함.

## 다중 루프
* 반복 안에서 다시 반복할 수 있음
* 이런 반복을 루프가 중첩되는 수준에 따라 '이중 루프, 삼중 루프' 라고 함.

## C언어의 불리언(boolean) 처리 방식

* C언어는 불리언 타입이 없음.
* 따라서 false는 0, 그리고 0아닌 모든 값은 true 1로 간주됨.

# 25/9/11 강의
## 알고리즘

## 연산자(operator)

1. 단 항 연산자 : 피연산자 1개  `a++`
2. 2항 연산자 : 피연산자 2개    `a>b`
3. 3항 연산자 : 피연산자 3개    `a?:b:c`

## 식과 식의 평가
* 식(expression): **변수, 상수, 연산자** 등을 사용하여 표현된 관계나 구조를 의미.
* 식의 평가: 식의 값을 알아내는 것을 평가라고 함.

## 알고리즘(Algorithm)
* 어떤 문제를 해결하기 위한 ***논리적인 절차나 방법을 순서대로 기술*** 한 것.
* 주로 ***언어적인 표현 방식*** 을 사용하며, 단계별로 수행해야 할 동작들을 순서대로 나열함.

## 순서도(Flowchart)

* 알고리즘을 그림 형태로 표현한 것.
* 일련의 처리 과정과 흐름을 시각적으로 보여주기 위해 **표준화된 기호** 사용함.
* 알고리즘의 흐름은 위에서 아래 방향으로 전개함.
* 알고리즘(또는 프로그램)이 흐르는 방향은 조건식에 따라 결정됨.

## 관계 연산자와 등가 연산자

* 관계 연산자: 왼쪽과 오른쪽의 피연산자의 대소 관계를 판단.
    * `<, <=, >=, >`
* 등가 연산자: 왼쪽과 오른쪽의 피연산자의 값이 동일한지 판단.
    * `==, =!`(True, False)
---

* 매개변수(Parameta): 함수를 정의할 때 함수에 전달 받은 값을 저장하는 변수

* 인수(Argument): 함수를 사용할 때 함수의 매개변수로 전달할 값.

* 함수를 호출하는 곳에서 argument를 함수에 전달하면, 함수는 전달 받은 인수를 이용해서 함수를 실행한 후 return문으로 결과 값을 호출한 곳으로 보냄.

* return 값의 자료형이 void인 경우 값을 반환하지 않음.

## 세 정수의 대소 관게와 중앙값
* 세 정수의 대소 관계는 **모두 13종류** 이다.
* 이 관계를 정리한 그래프를 **결정 트리(decision Tree)** 라고 한다.

## 세 정수의 중앙값
* 최댓값, 최솟값과는 다르게 중앙값을 찾는 절차는 매우 복잡함.
* 따라서 여러가지 알고리즘을 생각할 수 있다.
* 세 정수의 중앙값을 구하는 절차는 **퀵 정렬(Quick sort)** 를 이용한다.


# 25/9/4 강의

# [문자 크기](#h1에-해당) / [리스트](#리스트)

# 문자 크기

# h1에 해당
## h2에 해당
### h3에 해당
#### h4에 해당
##### h5에 해당
###### h6에 해당

*이텔릭체*

**볼드체**

---
# 리스트
* 언오더드 리스트
* 언
    * 탭
    * 탭
        * 탭
        * 탭
            * 변화없음
- 리스트

1. 오더드 리스트
2.
3.

# 코드 블럭
```c
#include <stdio.h>

int main(){
    printf("Hello World!\n");

    return 0;
}
```

인라인 코드 블럭 예시 : `<br>`

다른 예시: `Ctrl` + `A`

# 외부링크
[구글로 가기](https://google.com "구글 링크")

# [이미지](zhangye-9788010_1280.jpg "이미지 삽입")
