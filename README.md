# 최 태웅 (Choi Taeung)
### 202530235

# 25/12/04 기말고사(종강)

# 25/11/27 강의
## 자료구조 REVIEW
### 스택
* 후입선출(LIFO, Last In First Out) : 가장 나중에 넣은 데이터를 가장 먼저 꺼냄.
* 푸시(push) : 스택에 데이터를 넣는 작업
* 팝(pop) : 스택에서 데이터를 넣는 작업
* 꼭대기(top) : 푸시, 팝을 하는 위치
* 바닥(bottom) : 스택의 가장 밑바닥 부분

#### 기본 함수(1)
* Initialize() : 초기화.
* Push(): 푸시 함수, 꼭대기(top)에 데이터 넣기
* Pop(): 팝 함수, 꼭대기(top)에 데이터 꺼내기
* Peek(): 

#### 기본 함수(2)
* Clear()
* Capacity()
* Size()
* IsEmpty()
* IsFull() : 스택이 가득 찼는지 검사하는 함수. 가득 참(1)/아니면(0)을 반환.
* Search() : 임의의 값을 검색하는 함수.
* Print() : 모든 데이터 출력하는 함수, 스택의 모든 데이터를 바닥부터 순서대로 검색.
* Terminate() : 종료 함수, Initialize 함수로 확보한 스택을 해제.

### 큐(Queue)
* 선입선출(FIFO, First In First Out): 먼저 넣은 데이터를 가장 먼저 꺼냄.
* 인큐(en-queue): 큐에 데이터를 넣는 작업.
* 디큐(de-queue): 데이터를 꺼내는 작업.
* 프런트(front): 데이터를 꺼내는 쪽.
* 리어(rear): 데이터를 넣는 쪽.

* 리어로 부터 들어간 데이터를 프런트부터 채워 나감.
* 24인큐 : 리어에서 데이터 넣음. 0(1)
* 19디큐 : 프런트부터 데이터를 꺼냄.
    - 나머지 데이터 프런트로 하나씩 이동. 0(n)
* 데이터 입출입이 빈번한 경우 원형 큐로 구현하는 것이 효율적임.

#### 기본함수
* Initialize(): 초기화 함수.
* Enque(): 인큐 함수. 프런트(front)에서 데이터 넣기.
* Deque(): 디큐 함수. 리어(rear)에서 데이터 꺼내기.
* Peek(): 피크 함수. 프런트(front)에서 데이터 읽기.
* Clear():
* Capacity():
* Size():


### 검색(Search)
#### 선형 검색(linear search)
* 선형검색(linear search) 또는 순차검색(sequential search)이라고 함.
* 원하는 키 값을 갖는 데이터를 만날 때까지 맨 앞부터 순서대로 데이터를 검색.
* 시간 복잡도: O(n) 

#### 이진 검색(binary search)
* 오름차순 or 내림차순으로 정렬된 데이터를 검색.
* 배열의 '중간 값'을 선택하고 찾고자 하는 값과 비교.
* 만약 중간 값이 찾고자 하는 값보다 크면 '배열 왼쪽 부분'에서 탐색을 진행하고, 작으면 '배열 오른쪽 부분'에서 탐색 진행.
* 이 과정에서 찾고자 하는 값이 나올 때까지 반복함.

### 정렬(Sorting)
* 이름, 학번, 키 등 핵심 항목(key)의 대소 관게에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업.

* 오름차순
* 내림차순

#### 버블 정렬(bubble sort)
* 인접한 두 데이터를 비교하여 기준에 만족하면 데이터를 서로 교환, 완성될 때까지 반복.
* 오름차순 정렬의 두 데이터 비교하여 앞쪽 값이 더 크면 데이터를 교환.
* 내림차순 정렬의 두 데이터 비교하여 앞쪽 값이 더 작은 데이터를 교환.
* 시간 복잡도: O(n^2)

#### 퀵 정렬(quick sort)
* 리스트 가운데서 하나의 원소를 고름. -> 이것을 피벗(pivot)이라고 함.
* 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 리스트를 둘로 나눔.
* 이렇게 하면 배열이 두 부분으로 나눠짐.
* 이 두 개의 배열에서 각각 새로운 피벗을 만들어서 두개의 배열로 다시 나눔.
* 더 이상 배열을 쪼갤 수 없을 때 까지 계속 진행.
    - 재귀(Recursion)적으로 이 과정을 반복하는 의미이다.
* 이 과정은 분할 정복의 원리를 이용한 것이다.


* 피벗을 중심으로 문제 분할, 피벗을 기준으로 작은 값과 큰 값을 나열하는 정복 과정 거친 뒤, 모든 결과를 결합해서 큰 전체 문제를 해결함.
* 시간 복잡도: O(n log n)

#### 힙 정렬(heap sort)
* 최댓값, 최솟값을 쉽게 추출할 수 있는 자료 구조.
* 최대 힙 트리(내림차순 정렬)나 최소 힙 트리(오름차순 정렬)를 구성해 정렬을 하는 방법

* n개의 노드로 이루어진 완전 이진트리 구성함.
* 이때 루트 노드부터 부모노드, 왼쪽자식노드, 오른쪽자식노드 순으로 구성함.
* 정렬해야 할 n개의 요소들로 최대 힙(내림차순 기준)을 만듬.
* 다음으로 한 번에 하나씩 요소를 힙에서 꺼내, 배열의 뒤부터 저장함.
* 삭제되는 요소들(최댓값부터 삭제)은 값이 감소되는 순서로 정렬함.

#### 도수 정렬(counting sort)
* 원소의 대소 관계 판단 X, 빠르게 정렬하는 알고리즘.
    - 분포 수 세기(distribution counting) 정렬이라고도 함.

* 배열 내 요소 값들의 개수를 저장하는 카운트 배열(도수 분포표) f를 생성하고 배열의 모든 원소 값을 0으로 초기화함.
* 주어진 배열 a를 스캔, 원소 값이 배열 f의 index와 일치하는 곳에 카운트를 올리며 도수분포표 채움.

### 리스트(List)
#### 선형 리스트(Linear List)
* 데이터를 일렬로 나열하고 순서대로 저장하는 가장 간단한 형태의 자료구조.
* 논리적 순서와 물리적 순서가 일치, 메모리에 연속적으로 저장되는 특징이 있음.
* 배열이 대표적인 선형 리스트의 예.

* 장점
    - 인덱스(index)로 접근할 수 있기 때문에 접근 속도가 매우 빠름.
    - 연속된 메모리 공간에 존재하기 때문에 관리가 편함.

* 단점
    - 배열이 갖고 있는 메모리 사용의 비효율성 문제를 그대로 가짐.
    - 삽입&삭제 연산 후에 연속적인 물리 주소를 유지하기 위해 원소들을 이동시키는 추가 작업과 시간이 소요됨.

#### 연결 리스트(linked list)
* 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조.
* 데이터 노드(node)를 저장할 때 하나의 데이터와 그 다음 데이터로 가는 주소(다음 노드의 주소)를 함께 저장, 논리적으로 연결(link)하는 방식으로 자료 저장.
* 데이터는 논리적으로 연결되어 있으므로 배열과 달리 데이터의 삽입 삭제가 자유롭고, 자연스럽게 전체 크기를 늘리고 줄이는 것 또한 가능.

##### 연결 리스트 바리에이션들.
* 단순 연결 리스트(singly linked list): 데이터와 함께 다음 노드의 주소(포인터)를 함께 가지고 있는 구조.
* 이중 연결 리스트(doubly linked list): 데이터와 함께 이전과 다음 노드의 주소를 모두 함께 가지고 있는 구조.
* 순환 연결 리스트(circular linked list): 단순 연결 리스트의 마지막 노드가 첫 번째 노드의 주소를 가지고 있는 구조.
* 원형 이중 연결 리스트(circular doubly linked list): 이중 연결 리스트와 순환 연결 리스트를 합친 구조이다.

### 트리(tree)
* 트리를 구성하는 요소는 노드(node)와 가지(edge) 두가지다.
* 각각의 노드는 가지를 통해 다른 노드와 연결됨.

* 루트(root)노드: 트리의 가장 윗부분 위치, 트리에 단 1개만 존재.
* 단말(leaf)노드: 트리의 아랫부분 위치, 자식 노드 비존재.
* 내부(internal)노드: 단말 노드가 아닌 노드로 여기에는 루트 노드도 포함.

* 트리의 크기(size): 루트 포함한 모든 자손 노드의 개수
* 트리의 깊이(depth): 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수
* 트리의 레벨(level): 트리의 특정 깊이를 가지는 노드의 집합
* 트리의 차수(degree): 각 노드가 지닌 가지의 수
    - 트리의 최대 차수(degree of tree)
* 트리의 높이(height): 루트 노드에서 가장 깊숙이 있는 노드의 길이
* 서브 트리(subtree): 트리 안에서 다시 어떤 노드를 루트로 정하고 그 자손으로 이루어진 트리
* 널 트리(null tree): 노드, 가지가 없는 트리.

#### 이진 트리(binary tree)
* 노드가 왼쪽 자식과 오른쪽 자식을 갖는 트리
* 노드의 자식은 2명 이하만 유지해야함.
* 왼쪽 자식과 오른쪽 자식을 구분함.
* 왼쪽 자식을 루트로 하는 서브 트리를 왼쪽서브트리(left subtree), 오른쪽 자식을 다시 루트로 하는 서브 트리를 오른쪽서브트리(right subtree)라고 함.

#### 완전 이진 트리(complete binary tree)
* 루트부터 노드가 채워짐과 같은 레벨에서 왼쪽에서 오른쪽으로 노드가 채워져 있는 이진 트리
    1. 마지막 레벨을 제외한 레벨은 노드를 가득 채움.
    2. 마지막 레벨은 왼쪽부터 오른쪽 방향으로 노드를 채우되 반드시 끝까지 채울 필요는 없음.

* 높이가 k인 완전 이진 트리가 가질 수 있는 노드의 최댓값은 2^k+1 -1 개.
* 따라서 n개의 노드를 저장할 수 있는 완전 이진 트리의 높이는 log n개.
* 완전이진트리 에서 너비 우선 탐색을 하며, 각 노드에 0,1,2,... 값을 주면 배열에 저장하는 인덱스와 일대일로 대응.
    * 참고사항
        * 트리의 높이 h는 1부터 시작.
        * 최대 노드 수는 2^h -1
            - root는 노드가 하나이므로 -1이다.

* 트리의 레벨은 루트에서부터 노드까지 거친 층의 수를 나타내며, 루트는 보통 0레벨 or 1레벨로 봄.
* 높이는 트리의 최대 레벨과 같으며, 루트에서 가장 먼 리프 노드까지의 경로에 있는 레벨 수(혹은 간선의 최대 개수)를 의미함.

* 참고사항
    - 높이가 h일 때 최대 노드의 수 n은: n = 2^h - 1 
    - n개의 노드를 가질 때, 완전 이진트리의 최대 높이 h는: h = log(2)n + 1
        * (단, 높이를 1 부터 시작)

#### 이진 검색 트리(binary search tree)
* 이진트리가 다음의 조건을 만족하면 이진검색트리가 됨.
    1. 어떤 노드 N을 기준으로 왼쪽서브노드의 모든 키 값은 노드 N의 키 값보다 작아야 함.
    2. 오른쪽 서브 트리 노드의 키 값은 노드 N의 키 값보다 커야 함.
    3. 같은 키 값을 갖는 노드는 없음.

* 특징
    1. 구조가 단순함.
    2. 중위 순회를 하면 키 값의 오름차순으로 노드를 얻을 수 있음.
    3. 이진검색과 비슷한 방식으로 빠르게 검색할 수 있음.
    4. 노드를 삽입하기 쉬움.

* 검색 과정
    1. 루트에서 시작.
    2. 검색 값을 루트와 비교, 루트보다 작으면 왼쪽 재귀, 크면 오른쪽 재귀.
    3. 일치하는 값을 찾을 때까지 절차 반복.
    4. 검색 값이 없으면 null 반환.

* 삽입 과정
    1. Root에서 시작.
    2. 

* 삭제 3가지 방법
    1. 삭제할 노드가 **리프 노드인 경우**는 검색 후 바로 삭제함.
    2. 삭제할 노드에 **자식이 하나만 있는 경우**는 노드를 삭제, 자식 노드를 삭제된 노드의 부모에 직접 연결함.

    3. 삭제할 노드에 **자식이 둘 있는 경우**는 successor 노드를 찾는 과정이 추가됨.
        - successor 노드란? : 삭제할 노드의 값 보다 크면서 가장 작은 키를 가진 노드.
        - 즉, 오른쪽 서브 트리 중에서 가장 작은 값을 의미함.

        * 과정
            1. 삭제할 노드 찾기.
            2. 삭제할 노드의 successor 노드를 찾기.
            3. 삭제할 노드와 successor 노드의 값을 바꿈.
            4. successor 노드를 삭제.

### 해시법(hashing)
* 데이터를 저장할 인덱스를 해시 함수로 계산하여, 데이터의 검색, 추가, 삭제를 효율적으로 수행하는 자료구조.

* 해시 함수를 이용해 키(key)값을 고정된 길이의 해시 값으로 변환하고, 이 해시 값을 배열의 인덱스로 사용하여 데이터를 저장하는 방식입니다.

* 이 과정에서 여러 키가 동일한 해시 값으로 변환되는 해시 충돌이 발생할 수 있으며, 이를 해결하기 위해 체인법이나 개방 주소 법 같은 방법들이 사용됩니다.

* (추가 내용 적어야함.)

#### 번외 - 해시 값을 사용하는데 왜 충돌 발생하는가
* Git 등에서 쓰는 해시는 사실상 충돌이 없다고 간주할 만큼 강력한 암호학적 해시다.
* 이에 반해 자료구조 해시는 빠른 접근을 위해 설계된 약한 해시이다.
* 따라서, Git 같은 시스템에서 사실상 충돌이 거의 발생하지 않지만, 자료구조에서는 충돌이 자주 발생함.

    1. Git해시(SHA-1 / SHA-256)는 암호학적 해시(Cryptographic Hash)
        - 입력이 조금만 달라도 완전히 다른 해시가 나옴.(Avalanche effect)
        - 임의로 충돌을 만들기는 거의 불가능.
    
    2. 자료구조의 해시는 "빠르고 단순하기 위해 만든 해시 함수"
        * 자료구조(해시 테이블)에서 사용하는 해시는 목적이 전혀 다름.

        * 요구 조건
            - 계산이 매우 빨라야함.

### 체인법(chaining, Separate Chaining)
* 해시 테이블의 각 버킷이 리스트(연결 리스트 등)를 가지고 있어서, 충돌이 발생하면 그 버킷의 리스트에 노드를 추가하는 방식.

* 장점
    - 구현이 매우 간단.
    - 테이블이 거의 가득 차도 삽입 가능(list만 늘리면 됨)
    - 삭제가 쉬움.(리스트에서 node만 제거.)

* 단점
    - 충돌이 많아지면 리스트의 길이가 길어져 검색시간이 O(n)으로 악화.
    - 리스트를 위한 추가 메모리 사용
    - 포인터 사용으로 메모리 locality가 떨어져 느려질 수 있음

# 25/11/20 강의
## 트리 정의하기
* 트리 관련 용어
    - 트리를 구성하는 요소는 노드(node)와 가지(edge)
    - 각각의 노드는 가지를 통해 다른 노드와 연결되어 있음
    
    * 루트(root)
        - 트리의 가장 윗부분에 위치하는 노드
        - 하나의 트리에는 하나의 루트가 있음
        - 그림을 거꾸로 보면 나무 모양과 비슷함

    * 리프(leaf)
        - 트리의 가장 아랫부분에 위치하는 노드
        - '가장 아래에 위치한다'라는 말은 물리적으로 가장 아랫부분에 위치한다는 의미가 아님.

    * 자식(child)
        - 어떤 노드로부터 가지로 연결된 아래쪽 노드
        - 노드는 자식을 여러 개 가질 수 있음.

    * 부모(parent)
        - 어떤 노드에서 가지로 연결된 위쪽 노드
        - 노드는 1개의 부모를 가짐

    * 형제(sibling)
        - 같은 부모를 가지는 노드.

    * 조상(ancestor)
        - 어떤 노드에서 가지로 연결된 위쪽 노드 모두.

    * 자손(descendant)
        - 어떤 노드에서 가지로 연결된 아래쪽 노드 모두.

    * 레벨(level)
        - 루트로부터 얼마나 떨어져 있는지에 대한 값.

    * 차수(degree)
        - 노드가 갖는 자식의 수
        - 모든 노드의 차수가 n 이하인 트리를 n진 트리라고 함.

    * 높이(height)
        - 루트부터 가장 멀리 떨어진 리프까지의 거리 (리프 레벨의 최댓값)

    * 서브 트리(subtree)
        - 트리 안에서 다시 어떤 노드를 루트로 정하고 그 자손으로 이루어진 트리.
    * 널 트리(null tree)
        - 노드, 가지가 없는 트리

## 순서 트리의 탐색 방법 알아보기
* 너비 우선 탐색(breadth-first Search)
    - 낮은 레벨에서 시작해 왼쪽에서 오른쪽 방향으로 검색하고 한 레벨에서의 검색이 끝나면 다음 레벨로 내려감

* 깊이 우선 탐색(depth-first Search)
    - 리프까지 내려가면서 검색하는 것을 우선순위로 하는 탐색 방법
    - 리프에 도달해 더 이상 검색을 진행할 곳이 없는 경우에는 부모에게 돌아감
    - 그런 다음 다시 자식 노드로 내려감

    * 깊이 우선 탐색에서 가능한 노드 방문 종류
        - 전위 순회(Preorder)
            - (부모)노드 방문 -> 왼쪽 자식 -> 오른쪽 자식

        - 중위 순회(Inorder)
            - 왼쪽 자식 -> (부모)노드 방문 -> 오른쪽 자식

        - 후위 순회(Postorder)
            - 왼쪽 자식 -> 오른쪽 자식 -> (부모)노드 방문

## 이진트리 정의하기
* 이진트리(binary tree)
    - 노드가 **왼쪽 자식과 오른쪽 자식을 갖는 트리**
    - 노드의 **자식은 2명 이하만 유지**해야 함
    - **왼쪽 자식과 오른쪽 자식을 구분**함
    - 왼쪽 자식을 다시 루트로 하는 서브 트리를 왼쪽 서브트리(left subtree), 오른쪽 자식을 다시 루트로 하는 서브 트리를 오른쪽 서브 트리(right subtree)라고 함.

## 완전이진트리 정의하기
* 완전이진트리(complete binary tree)
    - 루트부터 노드가 채워져 있으면서 **같은 레벨에서는 왼쪽에서 오른쪽으로 노드가 채워져 있는 이진트리**
        1. 마지막 레벨을 제외한 레벨은 노드를 가득 채움
        2. 마지막 레벨은 왼쪽부터 오른쪽 방향으로 노드를 채우되 반드시 끝까지 채울 필요는 없음

    - 높이가 k인 완전이진트리가 가질 수 있는 노드의 최댓값은 2^k+1 - 1
        - 유의: 트리의 높이 h는 1부터 시작
        - 최대 노드 수는 2^h - 1 
        - root는 노드가 하나이므로 -1 임.
        - n개의 노드를 가질 때, 완전 이진트리의 최대 높이 h는: h = log(2)n+1

    - 따라서 n개의 노드를 저장할 수 있는 완전이진트리의 높이는 log n
    - 완전이진트리에서 너비 우선 탐색을 하며 각 노드에 0,1,2,...값을 주면 배열에 저장하는 인덱스와 일대일로 대응

    - 트리의 레벨은 루트에서부터 노드까지 거친 층의 수를 나타내며, 루트는 보통 0레벨 또는 1레벨로 봄.
    - 높이는 트리의 최대 레벨과 같으며, 루트에서 가장 먼 리프 노드까지의 경로에 있는 레벨 수(혹은 간선의 최대 개수)를 의미한다.

## 이진검색트리 살펴보기
* 이진검색트리(binary Search tree)
    - 이진트리가 다음의 조건을 만족.
        1. 어떤 노드 N을 기준으로 왼쪽 서브 트리 노드의 모든 키값은 노드 N의 키값보다 작아야 함
        2. 오른쪽 서브 트리 노드의 키값은 노드 N의 키값보다 커야 함.
        3. 같은 키값을 갖는 노드는 없음

    - 특징
        - 구조가 단순함.
        - 중위 순회를 하면 키값의 오름차순으로 노드를 얻을 수 있음.
        - 이진검색과 비슷한 방식으로 빠르게 검색할 수 있음.
        - 노드를 삽입하기 쉬움.

### 이진검색트리 만들기
* 노드를 삭제하는 Remove 함수(1)
    - 노드를 삭제할 때는 '세 가지 서로 다른 상황'에 놓이기 때문에 각각의 상황에 맞게 처리.

* A 자식 노드가 없는 노드를 삭제하는 경우
    - 삭제할 노드가 부모 노드의 왼쪽 자식이면 부모의 왼쪽 포인터를 NULL로 함
    - 삭제할 노드가 부모 노드의 오른쪽 자식이면 부모의 오른쪽 포인터를 NULL로 함

* B 자식 노드가 1개인 노드를 삭제하는 경우
    - 삭제 대상 노드가 부모 노드의 왼쪽 자식인 경우 부모의 왼쪽 포인터가 삭제 대상 노드의 자식을 가리키도록 함.
    - 삭제 대상 노드가 부모 노드의 오른쪽 자식인 경우 부모의 오른쪽 포인터가 삭제 대상 노드의 자식을 가리키도록 함.

* C 자식 노드각 2개인 노드를 삭제하는 경우
    1. 삭제할 노드의 왼쪽 서브 트리에서 키값이 가장 큰 노드를 검색
    2. 검색한 노드를 삭제 위치로 옮김(검색한 노드의 데이터를 삭제 대상 노드 위치로 복사)
    3. 옮긴 노드를 삭제
        - 옮긴 노드에 자식이 없으면 'A 자식 노드가 없는 노드를 삭제하는 경우'에 따라 노드 삭제.
        - 옮긴 노드에 자식이 1개만 있으면 'B 자식 노드가 1개인 노드를 삭제하는 경우'에 따라 노드 삭제.

## 해시법
### 해시법
* 해시법(hashing)
    - 데이터를 저장할 위치(인덱스)를 간단한 연산으로 구하는 것으로, 검색 뿐만 아니라 추가, 삭제도 효율적으로 수행하는 방법.
    - 표에 정리한 값을 해시값(hash value)이라고 하며, 이 해시값은 데이터에 접근 시 사용.
    - 해시값이 인덱스가 되도록 원래의 키값을 저장한 배열이 해시 테이블(hash table)
    - 해시 함수는 여기에서 살펴봤듯이 '나머지를 구하는 연산 또는 이런 나머지 연산을 다시 응용한 연산'을 사용
    - 해시 테이블의 각 요소를 버킷(bucket)이라고 함.
### 충돌
* 충돌(collision)
    - 저장할 버킷이 중복되는 현상
    - 키값과 해시값의 대응 관계가 반드시 1대1이라는 보증은 없음(보통 n대1)

* 충돌에 대한 대처
    1. 체인법: 같은 해시값을 갖는 요소를 연결 리스트로 관리
    2. 오픈 주소법: 빈 버킷을 찾을 때까지 해시를 반복

### 체인법
* 체인법(chaining)
    - 해시값을 갖는 데이터를 쇠사슬(chain) 모양으로 연결 리스트에서 연결하는 방법으로, 오픈 해시법(open hashing)이라고도 함.

* 같은 해시값을 갖는 데이터 저장하기
    - 배열의 각 버킷(해시 테이블)에 저장하는 값은 그 인덱스를 해시값으로 하는 연결 리스트의 첫 번째 노드(node)에 대한 포인터

* 버킷용 구조체(Node)
    - 개별 버킷의 자료형을 나타낸 것

* 키값으로 요소를 검색하는 Search 함수
    - 키값이 x->no

* 요소를 추가하는 Add 함수
    - 포인터 x가 가리키는 데이터를 추가하는 함수
        1. 해시 함수가 키값을 해시값으로 반환
        2. 해시값을 인덱스로 하는 버킷을 선택
        3. 선택한 버킷의 포인터가 가리키는 연결 리스트를 처음부터 순서대로 검색
            - 키값과 같은 값을 찾으면 그 노드를 리스트에서 삭제
            - 그렇지 않으면 삭제 실패.

* 모든 데이터를 삭제하는 Clear 함수
    1. 배열 표의 요소가 NULL이 아니면 그 해시값을 갖는 데이터가 연결 리스트로 존재하므로, 연결 리스트를 맨 앞부터 순서대로 검사하면서 모든 노드에 대한 메모리를 해제
    2. 검사 중인 배열 요소를 NULL을 대입
    3. 배열에 대한 모든 검사가 끝나면 모든 버킷이 '공백' 상태가 됨.

* 해시 테이블을 종료하는 Terminate 함수
    1. Clear 함수로 해시에 등록한 모든 데이터를 삭제
    2. Initialize 함수로 메모리에 확보한 해시 테이블(table)을 해제
    3. 해시 테이블의 크기를 저장하는 멤버 size를 0으로 초기화

### 충돌 살펴보기
* 충돌(collision)
    - 저장할 버킷이 중복되는 현상
    - 키값과 해시값의 대응 관계가 반드시 1대1 이라는 보증은 없음.(보통은 n대1)

### 오픈 주소법 이해하기
* 오픈 주소법(open addressing)
    - 충돌이 발생했을 때 재해시(rehashing)를 수행하여 비어 있는 버킷을 찾아내는 방법으로, 닫힌 해시법(closed hashing) 이라고도 함.
    - 빈 버킷을 만날 때까지 재해시(rehashing)를 여러 번 반복하므로 연결 탐사법(linear probing)이라고도 함.

# 25/11/13 강의
## 강의 진도 안내
- 7장: 문자열 검색 알고리즘
    - C언어를 이용해서 문자열 중에 원하는 문자열을 찾는 내용으로 자료구조와 연관성 적음.
    - 8장 생략
    - 검색과 관련해서 트리에서, 6장 정렬에서 검색의 기본은 학습함.

- 8장: 리스트 전형적인 자료 구조
    - 8-1: 리스트의 개념 설명
    - 8-2~4: 리스트 실기 프로그래밍.

- 9장: 트리 전형적인 자료 구조(개념 중요)

- 10장: ~~자료구조 응용이므로 생략.~~


## 선형 리스트
* 리스트(list)
    * 데이터를 **순서대로 나열**해 놓은 자료구조
    * 가장 단순한 구조를 가진 리시트를 선형 리스트 또는 연결 리스트라고 함.
    * 각 데이터의 연결 관계를 '이야기 전달하기 게임'에 비유할 수 있다.
    * 즉, 한 사람을 건너뛰어 이야기를 전달할 수 없음.

* 노드(node)
    * 리스트의 각 요소
    * 각각의 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 있음
    * 처음과 끝에 있는 노드는 특벼리 각각 머리 노드 , 꼬리 노드라고 함.
    * 하나의 노드에 대해 바로 앞에 있는 노드를 앞쪽 노드(predecessor node), 바로 뒤에 있는 노드를 다음 노드(successor node)라고 함.

* 배열로 선형 리스트 만들기
    * 다음 노드 꺼내기
        - 배열의 각 요소에는 연락할 순서대로 데이터가 저장
        - 전화를 걸기 위해 필요한 '다음 노드 꺼내기'는 1만큼 큰 인덱스를 갖는 요소에 접근.

    * 노드의 삽입과 삭제
        - 회원번호 55인 회원이 새로가입했고, 이 회원의 정보를 회원번호 12, 33 사이에 삽입할려면 삽입 요소 다음의 모든 요소를 하나씩 뒤로 밀어야 함.
        - 삭제하는 경우도 모든 요소를 뒤로 밀거나 앞으로 당김.
        - 이런 작업이 필요하므로 배열로 구현한 선형 리스트는 쌓이는 데이터의 크기를 미리 알아내야함.
        - 데이터의 삽입, 삭제에 따라 데이터를 모두 옮겨야 하기 때문에 ***효율이 나쁨***.

* 포인터로 연결 리스트 만들기
    * 노드용 구조체(Node)
        - 노드용 객체를, 연결 리스트에 데이터를 삽입할 때 만들고 삭제할 때 없애면, 데이터를 밀고 당기는 문제를 해결 할 수 있음.
        - 노드용 구조체 Node는 data와 next로 구성함.
            1. data ...데이터(Member)형
            2. next ...다음 노드에 대한 포인터(자기 자신과 같은 구조체형을 가리키는 포인터형.)\
        - 이와 같이 자기 자신과 같은 자료형의 객체를 가리키는 데이터가 내부에 포함.
        - 이러한 자료구조를 자기참조(self-referential)형 이라고 함.
    
    * 연결 리스트를 관리하는 구조체 List
        - 노드용 구조체 Node를 사용한 연결 리스트를 나타낸 것
        - List는 두 멤버로 구성, 모두 Node에 대한 포인터 자료형을 가짐.
            1. head는 연결 리스트의 머리 노드를 가리키는 머리 포인터
            2. cmt는 현재 선택한 노드를 가리키는 선택 포인터
        - '검색'한 노드를 선택하고 '삭제'하는 용도로 사용.
        - 연결 리스트를 관리하는 구조체 List는 2개의 포인터만 가짐.

        * cmt: 현재 선택한 노드를 가리키는 포인터(커서)
    
    * 꼬리 노드를 삭제하는 RemoveRear 함수
        - 리스트에 노드가 1개뿐인지(list -> next == NULL)아니면 2개 이상인지에 따라 서로 다른 작업을 수행
            1. 리스트에 노드가 1개만 있는 경위 머리 노드를 삭제하는 것과 같으므로 RemoveFront 함수로 처리
            2. 리스트에 노드가 2개 이상있는 경우.

* 커서로 연결 리스트 만들기
    * 커서를 사용한 연결 리스트
        - 프로그램 실행 중에 데이터의 개수가 크게 바뀌지 않고 데이터 개수의 최댓값을 미리 알 수 있다고 가정하면 배열을 사용해 효율적으로 연결리스트를 운용할 수 있음

        - 배열의 커서에 해당하는 값은 다음 노드에 대한 포인터가 아닌 다음 노드가 들어 있는 요소의 인덱스에 대한 값이다.
            * 여기서 포인터 역할을 하는 인덱스를 커서(cursor)라고 함.

## 프리 리스트 구현하기
* 프리 리스트(free list)
    - 삭제한 레코드를 관리하기 위해 사용하는 자료구조.
    - 삭제한 여러 레코드를 관리하면 앞에서 발생한 '사용하지 않는 빈 배열'의 문제를 해결할 수 있음.
    - 프리 리스트는 앞에서 다룬 '커서로 연결 리스트 만들기'와 같은..

## 원형 리스트 알아보기
* 원형 리스트(circular list)
    - 선형 리스트의 꼬리 노드가 머리 노드를 가리킴
    - 고리 모양으로 나열된 데이터를 저장할 떄 알맞은 자료구조
    - 원형 리스트와 선형 리스트의 차이점은 꼬리 노드의 다음 노드를 가리키는 포인터가 널(NULL)이 아니라 머리 노드의 포인터값이라는 점
    - 원형 리스트는 선형 리스트에서 사용했던 것과 같은 자료형을 사용할 수 있음.

* 빈 원형 리스트를 판단하는 방법
    - 노드가 없는(비어있는) 원형 리스트인지 판단하려면 오른쪽 식을 사용

* 노드가 1개인 원형 리스트를 판단하는 방법
    - 노드가 1개라면 머리 노드의 다음 포인터는 자기 자신인 머리 노드를 가리킴

* 포인터가 머리 노드를 가리키는지 판단하는 방법
    - Node형 변수 p가 리스트에 있는 어떤 노드를 가리키는 경우 p가 가리키고 있는 노드가 원형 리스트의 머리 노드인지 판단하려면 오른쪽 식을 사용

* 포인터가 꼬리 노드를 가리키는지 판단하는 방법

## 이중 연결 리스트 알아보기
* 이중 연결 리스트(doubly linked list)
    - 선형 리스트의 가자 큰 단점은 다음 노드는 찾기 쉽지만 앞쪽의 노드를 찾으려면 비용이 든다는 점을 개선한 자료구조
    - 각 노드에는 다음 노드에 대한 포인터와 앞쪽의 노드에 대한 포인터가 주어짐.

## 원형 이중 연결 리스트 알아보기
* 원형 이중 연결 리스트(circular doubly linked list)
    - 앞에서 공부한 두 가지의 개념을 합함.


# 25/11/06 강의
## 번외 - 오프라인 행사 관련 후기.


## 퀵 정렬 - 10/31 강의에서 이어짐.

### qsort 함수 정렬
* qsort 함수
    * bsearch 함수와 마찬가지로 int형이나 double형 등의 배열뿐만 아니라 구조체형 배열 등 모든 자료형의 배열에 적용.
    * 전달하는

## 병합 정렬

### 정렬을 마친 배열 병합하기 
* 병합(merge)
    * 각 배열에서 선택한 요소의 값을 비교하여 작은 값의 요소를 꺼내 새로운 배열에 넣는 작업 을 반복하여 정렬을 마치는 배열을 만듦.

    * 요소의 개수가 na개인 배열 a와 요소의 개수가 nb개인 배열 b를 병합하여 배열 c에 저장

    * 이 함수에서는 세 개의 배열 a,b,c를 동시에 스캔
        - 이때 각 배열이 선택한 요소의 인덱스는 pa, pb, pc
        - 이 인덱스를 저장한 변수를 커서라고 함.
    
    * 처음에는 첫 요소를 선택하므로 커서를 모두 0으로 초기화

### 병합 정렬 하기
* 병합 정렬(merge sort)
    * 정렬을 마친 배열의 병합을 응용하여 분할 정복법에 따라 정렬하는 알고리즘
    
    * 먼저 배열을 앞부분과 뒷부분으로 나눔
    
    * 나눈 두 배열을 각각 정렬 및 병합하면 배열 모두 정렬 가능.

    

* 알고리즘
    * 배열의 요소 개수가 2개 이상인 경우
        1. 배열의 앞부분을 병합 정렬로 정렬
        2. 배열의 뒷부분을 병합 정렬로 정렬
        3. 배열의 앞부분과 뒷부분을 병합.

* 시간 복잡도
    - 배열 병합의 시간 복잡도는 O(n)이다.


## 힙 정렬
### 힙 정의하기

* 힙(heap)
    - ***부모의 값이 자식의 값보다 항상 크다*** 는 조건을 만족하는 **완전 이진트리**.
    
    - 부모와 자식 관계는 항상 '**부모의 값 >= 자식의 값**'
        - 힙의 가장 위쪽에 있는 **루트가 가장 큰 값**이 됨.
    
    - **형제 사이의 대소 관계는 일정하지 않음**.

* 힙 정렬
    - 가장 큰값이 루트에 위치 하는 특징을 이용하는 정렬 알고리즘.
        1. 힙에서 가장 큰값인 루트를 꺼냄
        2. 루트 이외의 부분을 힙으로 전환
    
    - 힙 정렬은 선택 정렬을 응용함.

* 루트를 없애고 힙 상태 유지.
    - 루트를 없앤 다음 다시 힙을 만들기 위해 요소를 알맞은 위치로 내려보내야하는 순서는 아래와 같다.
        1. 루트 꺼냄.
        2. 마지막 요소를 루트로 이동.
        3. 자기보다 큰 값을 가지는 자식 요소와 자리를 바꾸며 아래쪽으로 내려가는 작업을 반복
            - 이때 자식의 값이 작거나 잎에 다다르면 작업이 종료됨.

* 트리의 종류와 힙
    - 최대힙은 부모 노드가 자식 노드보다 큰 경우를 말함.
        - 최소힙은 그와 반대이다.

* 추가로...
    - 우선순위 큐를 위해 고안된 완전 이진트리
    - 반정렬 상태 유지.


## 도수 정렬

### 도수 정렬하기

* 도수 정렬
    - 지금까지의 정렬 알고리즘은 두 요소의 키값을 비교해야했음.
    - 도수 정렬은 요소를 비교할 필요가 없다는 특징이 있음

* 도수 정렬 알고리즘
    - 도수분포표 만들기
    - 누적도수분포표 만들기
    - 목적 배열 만들기
    - 배열 복사하기

* 도수(계수) 정렬
    - 데이터의 대소 관게를..


# 25/10/31 보강

## 단순 선택 정렬 - straight selection sort
* 아직 정렬하지 않은 부분에서 값이 가장 작은 요소를 선택하고 아직 정렬하지 않은 부분의 첫 번째 요소와 교환

* 교환 과정
    1. 아직 정렬하지 않은 부분에서 가장 작은 키의 값(a[min])을 선택
    2. a[min]과 아직 정렬하지 않은 부분의 첫 번째 요소를 교환

    - 이 과정을 n - 1회 반복하면 됨.

* 실습 6-4
    - 단순 선택 정렬을 수행하는 함수
    - 단순 선택 정렬 알고리즘의 요솟값을 비교하는 횟수는 n²-n / 2회
    - 서로 떨어져 있는 요소를 교환하는 것이기 때문에 불안정적.

## 단순 삽입 정렬
* straight insertion sort
    - 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 '삽입하는' 작업을 반복하는 정렬알고리즘.
    - 아직 정렬되지 않는 부분의 첫 번째 요소를 정렬된 부분의 알맞은 위치에 삽입
    - 아래의 두 조건 중 하나를 만족할 때 까지 j를 1씩 감소하면서 대입하는 작업을 반복
        1. 정렬된 열위 왼쪽 끝에 도달
        2. tmp보다 작거나 같은 key를 갖는 항목 a[j - 1]을 발견
    
    - 드모르간 법칙 적용으로 아래의 두 조건이 모두 성립할 때까지 반복
        1. j가 0보다 큼
        2. a[j - 1]값이 tmp보다 큼.

* 장점
    - 정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라짐.
* 단점
    - 삽입할 위치가 멀리 떨어져 있으면 이동(대입)해야 하는 횟수가 많아짐.

##### 단순 정렬의 시간 복잡도 - O(n²)으로 효율이 매우 떨어짐.

## 셀 정렬
* shell sort
    - 단순 삽입 정렬의 장점은 살리고 단점을 보완한 정렬 알고리즘
    - 정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행
    - 그 그룹을 합치면서 정렬을 반복하여 요소의 이동 횟수를 줄이는 방법
* 4-정렬
    - 4칸만큼 떨어진 요소를 모아 그룹을 4개로 나누어 정렬하는 방법
    - 아직 정렬을 마친 상태는 아니지만 정렬을 마친 상태에 가까워짐.
* 2-정렬
    - 2칸만큼 떨어진 요소를 모아 두 그룹({7,3,8,4},{1,2,6,5})으로 나눔.
    - 정렬을 마치고 나면 각각의 그룹은({3,4,7,8}, {1,2,5,6})으로 정렬됨.
* h-정렬
    - 셸 정렬 과정에소 수행하는 각각의 정렬
        1. 2개 요소에 대해 '4-정렬'(4개의 그룹) 
        2. 4개 요소에 대해 '2-정렬'(2개의 그룹)
        3. 8개 요소에 대해 '1-정렬'(1개의 그룹)
    - 증분값(h값)의 선택
        - h값은 n부터 감소하여 마지막에 1이 되면 됨
        - 두 그룹은 서로 섞이지 않음.
        - 섞이지 않으면 c를 합쳤을 때 다시 처음 단계인 a와 동일한 상태가 됨.
        - 그러면 다시 a의 학생을 정렬하는 것과 같아서 그룹을 나누었음에도 정렬 알고리즘이 충분히 작동하지 않음.
        - h값이 서로 배수가 되지 않도록 해야 요소가 충분히 섞여 효율적인 정렬을 기대할 수 있음
        - 아래 수열을 거꾸로 살펴보면 1부터 시작하여 3배한 값에 1을 더하는 수열.
            - ` h = ..., -> 121 -> 40 -> 13 -> 4 -> 1 `

## 퀵 정렬
* quick sort
    - 일반적으로 사용되고 있는 아주 빠른 정렬 알고리즘
    - 그림 6-19 참조.
        - 학생 수가 8명인 그룹을 키 순서대로 정렬한 모습.
            1. 먼저 어느 한 사람의 키를 선택
            2. 키가 168cm인 학생 A를 선택할 경우 그 학생을 기준으로 학생 A의 키보다 작은 사람의 그룹과 큰 사람의 그룹으로 나눔
            3. 이때 이 학생 A의 키를(그룹을 나누는 기준) 피벗(pivot)이라고 함.
            4. 각 그룹에 대해 피벗 설정과 그룹 나눔을 반복하며 모든 그룹이 1명이 되면 정렬을 마침.

## 배열을 두 그룹으로 나누기
* 배열을 두 그룹으로 나누기
    * 그룹을 나누려면 피벗 이하의 요소를 배열 왼쪽으로, 이상의 요소를 배열 오른쪽으로 옮겨야 함.
        1. a[pl] >= x가 성립하는 요소를 찾을 때까지 pl을 오른쪽으로 옮김.
        2. a[pr] <= x가 성립하는 요소를 찾을 때까지 pr을 왼쪽으로 옮김.

    * pl지점은 피벗값 이상의 요소가 있는 지점, pr지점은 피벗 값 이하의 요소가 있는 지점.
    * pl과 pr이 교차하면 그룹을 나누는 과정이 끝나고 배열은 아래처럼 두 그룹으로 나누어짐.
        - 피벗 이하의 그룹: `a[0], ..., a[pl-1]`
        - 피벗 이상의 그룹: `a[pr+1], ..., a[n-1]`

* 피벗과 같은 값을 가지는 그룹
    - 그룹을 나누는 작업이 끝난 다음 pl > pr + 1인 경우에는 다음과 같은 그룹이 생길 수 있음.
        - 피벗과 일치하는 값을 가지는 그룹: `a[pr+1], ..., a[pl-1]`
    - b,c,d 왼쪽 커서, 오른쪽 커서가 피벗 이상, 피벗 이하의 요소를 찾아 멈춘 단계
    - d pl,pr이 동일한 요소인 a[4] 위에 있고 이때 동일한 요소인 a[4]와 a[4]를 교환
    - 동일한 요소를 교환하는 시도가 의미 없어 보이나, 이 시도는 아무리 많아야 1회이므로 괜찮다.
    - e 계속 스캔하면 pl, pr이 교차하면서 그룹을 나누는 과정을 마침.

# 25/10/30 강의

## 스택(stack) - 1
* 데이터를 일시적으로 저장하기 위해 사용하는 자료구조.
* 입출력 순서는 후입선출(LIFO, Last In First Out)방식
    - 즉, 가장 나중에 넣은 데이터를 가장 먼저 꺼냄

* 푸시(push): 스택에 데이터를 넣는 작업
* 팝(pop): 데이터를 꺼내는 작업
* 꼭대기(top): 푸시, 팝을 하는 위치
    - 테이블에 겹겹이 쌓은 접시처럼 데이터를 넣는 작업도 꺼내는 작업도 위쪽부터 수행
* 바닥(bottom): 스택의 가장 밑바닥 부분

## 스택 - 2
* 구현 예시
    - 함수를 호출하고 실행할 때 프로그램 내부에서는 스택을 사용
    - 가장 먼저 main함수를 실행, z 함수를 호출함.
    - 호출된 함수 z는 x함수와 y함수를 순서대로 호출.
    - 함수를 호출할 때는 **push**, 함수가 실행 및 종료하고 호출한 원래의 함수로 리턴할때는 종료할 함수를 **pop**함.

    - main -> z -> x의 순서대로 함수 호출.
        - 이때, 스택의 상태는 호출하는 함수의 역순으로 겹겹이 쌓여 있어, 함수 호출이 ***계층 구조***로 이루어짐.
        - 이 상태에서 x함수의 실행이 종료되면 x함수만 **pop**함.

## 스택 만들기 - 1
* 스택 구조체 IntStack
    - 스택으로 사용할 배열을 가라키는 포인터 stk
        - index가 0인 요소를 스택의 바닥(bottom)이라 함.
        - 배열의 메모리 공간 할당은 Initialize 함수로 생성
    - 스택의 최대 용량 max
        - 배열 stk의 요소 개수와 같음
    - 스택 포인터 ptr
        - 스택에 쌓여 있는 데이터의 개수를 나타냄
        - 스택이 비어 있으면 ptr의 값은 0, 가득 차 있으면 max.

## 큐
* 데이터를 일시적으로 쌓아 두기 위한 자료 구조
    - 선입선출 방식.(FIFO)

### 큐 예시
* a 배열의 프런트부터 4개(19, 22, 37, 53)의 데이터가 들어가 있는 모습
* b 24 인큐
    - 리어의 데이터가 저장된 que[3]의 다음 요소 que[4]에 24를 저장
    - 이 처리의 복잡도는 **O(1)**이고 적은 비용으로 구현 가능.
* c 19 디큐
    - 

### 링 버퍼
* 배열의 처음이 끝과 연결되었다고 보는 자료구조
* 프런트: 논리적인 맨 처음 요소의 인덱스
* 리어: 논리적인 맨 끝 요소의 하나 뒤의 인덱스(다음 요소를 인큐할 위치를 미리 지정)
* 변수 프런트와 리어의 값은 인큐와 디큐를 수행함에 따라 변화, 배열 요소를 앞쪽으로 옮기지 않는 큐를 구현할 수 있음.
* 처리의 복잡도는 **O(1)**.

## 정렬 - sorting
* 정렬
    * 핵심 항목(key)의 대소 관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업
    * 키값이 작은 데이터를 앞쪽에 놓으면 오름차순 정렬, 반대로 놓으면 내림차순 정렬.

* 정렬 알고리즘의 안정성
    - 같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지되는 것.

* 정렬 알고리즘의 핵심 요소
    - 교환, 선택, 삽입

### 버블 정렬
* 패스(pass)
    - 이웃한 요소를 비교, 교환하는 작업을 첫 번째 요소까지 계속.
    - 요소의 개수가 n개인 배열에서 n-1 회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동함
    - 이런 일련의 과정(비교, 교환 작업)을 패스라고 함.

* 패스 수행 횟수
    - 두 번째 패스의 비교 횟수는 첫 번째 패스보다 1회적은 n-2회
        - 그 이유는 패스를 1회 수행할 때마다 정렬할 요소가 하나씩 줄어들기 때문.
    
    - 패스를 k회 수행하면 앞쪽의 요소 k개가 정렬
    - 모든 정렬이 끝나려면 n-1회의 패스가 수행되어야함.

* 알고리즘 개선
    - 어떤 시점 이후에 교환이 수행되지 않는다면 그보다 앞쪽의 요소는 이미 정렬 마친 상태라고 생각하면됨.
    - 이미 배열이 정렬을 마친 상태라면 그 이후의 패스는 요소 교환을 하지 않음
    - 즉, 어떤 패스에서 

# 25/10/23 강의

## 검색과 키, 배열 검색

* 주소록 검색
    - 특정 항목에 주목함.
    - 주목하는 항목을 키(key)라고 함.
        * 예시
        1. 국적이 한국인 사람을 찾습니다.
            - 키값과 일치하게 지정 (한국)
        2. 나이가 21세 이상 27세 미만인 사람을 찾습니다.
            - 키값의 구간을 지정 (21세 이상 27세 미만)
        3. 어떤 낱말과 발음이 가장 비슷한 이름의 사람을 찾습니다.
            - 키값과 비슷하도록 지정 (발음이 가장 비슷한 이름)

    - 단순한 정수 값이면 데이터 값을 키 값이라고 생각하나, 키는 데이터의 '일부'다.
    - 하나만 지정, 논리곱이나 논리합을 사용하여 복합해서 지정함.

* 배열 검색 - 공통: 빠른 검색 실행함.
    - 선형 검색 : 무작위로 늘어놓은 데이터 모임
    - 이진 검색 : 일정한 규칙으로 늘어놓은 데이터 모임
    - 해시법 : 추가, 삭제가 자주 일어나는 데이터 모임
        - 체인법 : 같은 해시값의 데이터를 선형 리스트로 연결하는 방법
        - 오픈 주소법: 데이터를 위한 해시값이 충돌할 때 재해시하는 방법

### 선형 검색
* 선형 검색 다루기(1)
    * **선형 검색(linear search)** 또는 **순차 검색(sequential search)**
        - 요소가 **직선 모양으로 늘어선 배열**에서의 검색은 원하는 키값을 갖는 요소를 만날 때까지 **맨 앞부터 순서대로 요소를 검색**.

    * 선형 검색에서 배열 검색의 종료 조건
        1. 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우 **(검색 실패)**
        2. 검색할 값과 같은 요소를 발견한 경우 **(검색 성공)**
        - 배열 요소의 개수가 n개일 때 1,2 조건을 판단하는 횟수는 **평균 n/2 회**다.

* 선형 검색 다루기(2)
    * 요소 개수가 n인 배열 a에서 값이 key인 요소를 검색하는 코드
        1. 배열을 검색할 때 배열 요소의 인덱스를 가리키는 변수는 i
        2. i는 0으로 초기화하고, 요소를 하나 검색할 때마다 while문이 제어하는 루프 본문의 끝에서 증가
        3. 배열 검색 종료 조건 중 어느 하나라도 성립한 경우에는 while 문을 빠져나감.

        ```C
            int i = 0;
            while (1){
                if(i == n)
                    return -1;  //검색실패 
                if(a[i] == key)
                    return 1;   //검색성공
                i++
            }
        ```

* 선형 검색 다루기(3)
    - search 함수는 배열 a의 처음부터 끝까지 n개의 요소를 대상으로 값이 key인 요소를 선형 검색
    - 반환값은 발견한 요소의 인덱스
    - 만약 값이 key인 요소가 여러 개 존재한다면 반환값은 검색 과정에서 처음 발견한 요소의 인덱스
    - 값이 key인 요소가 존재하지 않으면 -1 반환.

    ```C
        int main(void) 
        { 
            int nx, ky;
            puts("선형 검색");
            printf("요소 개수: ");
            scanf("%d",&nx);
            int *x= calloc(nx, sizeof(int)); // 요소의 개수가 nx인 int형 배열 x를 생성 
            for(int i = 0; i < nx; i++) { 
                printf("x[%d]:",i); 
                scanf("%d",&x[i]); 
            } 
            printf("검색값: ");
            scanf("%d",&ky);
            int idx = search(x, nx, ky);// 배열 x의 값이 ky인 요소를 선형 검색
            if(idx ==- 1) 
                puts("검색에 실패했습니다.");
            else 
                printf("%d(은)는 x[%d]에 있습니다. \n", ky, idx);
            free(x); // 배열 x를 해제

            return 0;
        }
    ```

* 선형 검색 다루기(4,5)
    - 선형 검색 구현 (search1.c)

### 보초법검색
* 보초법(sentinel method)
    - 종료 조건을 검사하는 비용을 반으로 줄이는 방법

* 보초법을 이용한 선형 검색
    - 배열의 요소 a[0] ~ a[6]은 원래 데이터
    - 맨 끝 요소 a[7]은 검색하기 전에 준비하는 보초
    - 원하는 값이 원래의 데이터에 존재하지 않아도 보초인 a[7]까지 검색하면 종료조건 2가 성립.
    - 이렇게 하면 원하는 키값을 찾지 못했을 때 종료 조건 1이 없어도 됨.
    - 보초는 반복문에서 종료판단 횟수를 2회에서 1회로 줄이는 역할.

    * **참고** 선형 검색에서 배열 검색의 종료 조건
        1. 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우
        2. 검색할 값과 같은 요소를 발견한 경우.

* 보초법 검색 다루기

### 이진 검색
* 이진 검색
    - 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘
* 이진 검색에서 배열 검색의 종료 조건
    1. 중앙 요소와 key가 일치하는 경우(검색 성공)
    2. 검색 범위가 더 이상 없는 경우(검색 실패)
* 검색에 필요한 비교횟수
    - 검색을 반복할 떄마다 검색 범위가 절반이 되므로 검색에 필요한 비교 횟수의 평균값은 log n
    - 성공한 경우에는 대략 log n - 1회
    - 실패한 경우는 log(n+1)회

### 복잡도
* 복잡도(complexity)
    - 프로그램의 실행 속도는 프로그램이 동작하는 HW나 컴파일러 등의 조건에 따라 달라짐
    - 알고리즘의 성능을 객관적으로 평가하는 기준

* 복잡도의 두 가지 요소
    1. 시간 복잡도: 실행에 필요한 시간을 평가한 것
    2. 공간 복잡도: 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것

* 시간 복잡도와 공간 복잡도
    - 앞 장에서 배운 '소수'를 찾는 프로그램은 알고리즘을 선택할 때 두 복잡도(시간, 공간)의 균형을 생각할 필요성이 있음.

* 선형 검색의 시간 복잡도
    - O(f(n)) + O(g(n)) = O(max(f(n), g(n)))
        - 일반적으로 O(f(n))과 O(g(n))의 복잡도 계산하는 방법.

### 정렬된 배열에서 검색하는 bsearch 함수 알아보기
* bsearch
    - C언어 표준 라이브러리는 다양한 요소의 자료형을 가진 배열에서도 검색 가능한 bsearch 함수를 제공
    - 이진 검색에서 따왔지만, 내부적으로 항상 이진 검색 알고리즘을 사용하지는 않음.

    * 특징
        1. 검색 대상의 배열은 항상 정렬되어 있어야 함
        2. 검색하는 값과 같은 요소가 여러 개 존재하는 경우, 항상 가장 앞쪽에 있는 요소를 찾아내는건 아님.
# 25/10/16(중간고사)

# 25/10/2 강의
## 배열 요소를 역순으로 정리(1)
- 배열 요소를 역순으로 정렬.
    - 왼쪽 요소의 인덱스 ... i
    - 오른쪽 요소의 인덱스 ... n - i - 1

* 두 값의 교환
    - 1: t = x; x값을 t에 보관
    - 2: x = y; y값을 x에 대입
    - 3: y = t; t에 보관한 처음 x값을 y에 대입

## 배열 요소를 역순으로 정리(2)

- 실습 2-7(1)
- swap은 'type형 변수 x, y'의 값을 교환하는 함수 형식의 매크로
- 함수 형식 매크로는 프로그램을 컴파일하는 과정에서 그대로 치환
- ary_reverse 함수는 함수 형식 매크로 swap을 n/2회 호출하여 배열의 요소를 역순으로 정렬. 


## 배열 요소의 최대값 구하기(1)
1. rand함수, srand 함수, time 함수의 선언이 들어 있는 헤더를 포함
2. 난수의 seed(씨앗)를 초기화하기 위해 srand 함수를 호출
3. 난수를 생성하기 위해 rand 함수를 호출

## 기수 변환하기(1)
* 정수 값을 임의의 기수(cardinal number)로 변환하는 알고리즘
    - 10진수 정수를 n진수 정수로 변환할려면
    - 정수를 n으로 나눈 나머지를 구하는 동시에 그 몫에 대해 나눗셈을 반복
    - 이 과정을 몫이 0이 될 때까지 반복
    - 이 과정에서 구한 나머지를 거꾸로 늘어 놓은 숫자가 기수로 변환한 숫자
    - 기수가 10단위를 넘는 경우 0 ~ 9에 이어지는 숫자로 알파벳 문자인 A, B, ...를 사용
    - 16진수는 아래 16개의 문자로 표현되는 수(0,1,2,3,4,5,6,7,8,9,**A,B,C,D,E,F**)

## 기수 변환하기(2)
* 실습 2-8[A](1)
    - 기수 변환을 수행하는 프로그램
    - card_convr함수는 정수 x를 n진수로 변환한 숫자 문자의 정렬을 char형 배열 d에 저장 및 그 자릿수(배열에 저장한 문자 수)를 반환하는 함수.
    - char형의 배열 dchar는 "0123456789ABCDFEFGHIJKLMNOPQRSTUVWXYZ"

## 소수 나열하기(1)
* 소수(prime number)

## 다차원 배열(multidimensional array)
* 배열을 요소로 하는 배열
    * 배열을 자료형으로 하면 2차원 배열이고, 2차원 배열을 자료형으로 하면 3차원 배열

- 1차원 배열: 지금까지 배운 '단일 자료형을 가지는 배열'
- 2차원 배열의 도출
    1. [a] int형 .. int 자료형
    2. [b] int[3]형 ... int를 자료형으로 하는 단일 요소가 3개인 배열
    3. [c] int[4][3]형 ... int를 자료형으로 하는 단일 요소가 3개인 배열을 자형으로 하는 요소 개수가 4개인 배열.

## 구조체(structure)
- 임의의 자료형의 요소를 조합하여 다시 만든 자료구조

* 구조체형과 멤버의 접근
    1. 구조체 선언
        - 구조체에 붙는 이름인 xyz를 구조체 태그라고 함.
        - 구조체를 구성하는 요소를 구조체 멤버라고 함.
    2. 구조체형을 갖는 객체 정의
        - struct xyz 형을 갖는 객체 a를 정의
        - 구조체의 객체 안 멤버는, 연산자를 사용하여 접근
    3. 포인터가 객체를 가리키도록 선언
        - p가 구조체형 객체에 대한 포인터일 때 p가 가리키는 객체의 멤버 x에 접근하는 형식은 연산자를 사용함.

- 구조체 동의어 정의
    1. 구조체는 태그 이름 xyz만으로 구조체 자료형의 이름으로 지정할 수 없음.
    2. 구조체 자료형의 이름은 struct xyz처럼 두 단어로 구성해야함.
    3. typedef 선언을 사용해 짧은 이름으로 다시 만들어 사용할 수 있음.
    4. 이제 하나의 단어 xyz만으로 구조체 자료형의 이름을 나타낼 수 있음.
    5. 이렇게 하면 변수 a와 포인터 p를 간단하게 선언하고 정의할 수 있음.
    

# 25/9/25 강의

## 배열(array)

* 배열은 같은 자료형의 변수로 이루어진 요소가 모여 직선 모양으로 줄지어 있는 자료구조.
* 네모 칸 안에 쓰인 숫자나 문자가 요소 값이고, 네모 칸의 왼쪽 또는 위쪽에 쓰인 작은 숫자가 인덱스 값.(index)

## 배열 이름[인덱스]
* 배열의 개별 요소에 접근할 때 인덱스 식(subscript expression)을 사용.
* 배열의 요소 값을 초기화하며, 배열을 선언하는 프로그램.
* 각 요소를 처음부터 순서대로 쉼표(,)로 구분하여 줄지어 놓고 {}로 둘러쌈으로써 배열 요소 초기화.
* sizeof(a)로 전체 배열이 할당된 메모리 크기를 구하고, sizeof(a[0])로 첫 번째 요소가 할당된 메모리 크기를 구한 다음, 전체 배열 크기를 첫 요소 크기로 나눈 몫이 요소 개수가 됨.

### 수식
`sizeof(배열명)` / `sizeof(자료형)`
* 자료형에는 int, char, double 등을 사용.

### 메모리 할당 
* calloc, malloc 함수는 힙(heap)이라는 특별한 '빈 공간(free space)'에 기억 장소 확보함.
    * 사용 할 떄는 헤더 `#include <stdlib.h>` 사용

* calloc(clear and allocation): 메모리를 할당하고 0으로 초기화.
1.일반적으로 메모리 1개를 설정하기 위해서 calloc 함수를 사용하지 않음.
2.배열처럼 여러 개 요소를 할당, 초기값을 0으로 맞추고 싶을 때 유용.
3.배열은 정적 메모리 할당이고, calloc 함수는 동적 메모리 할당이다.
-> 배열은 컴파일할 때 크기가 정해져야 하지만, 런타임에 원하는 크기만큼 할당할 수 있음.
-> 즉, 가변크기 할당 가능.

* malloc(memory allocation): 메모리를 할당만 하고 초기화는 X. (가비지)
* heap : 완전 이진 트리의 한 종류로 최대힙과 최소힙이 존재.

#### 메모리 해제
* 확보한 메모리가 불필요하면 그 공간을 해제해야 하는데 이를 위해 제공되는 함수가 free함수다.
    * 프로그램을 실행하는 도중에도 원하는 시점에 제거할 수 있음.
* `free()`는 *동적으로* **할당된 메모리를 해제하는 역할**을 하는 것.

## 스택 메모리
##### 스택(stack) 메모리는 자료구조의 스택 (FIFO)과는 다름.
- 스택 메모리는 메모리 관리 방식이지 메모리 접근 방식이 아님.
- 그러므로 FIFO를 따르는 것이 아니라 index를 통해 입출력을 함.

## 배열 요소의 최댓값 구하기 - maxof()
- maxof는 내장 함수가 아님.
- 주사(traverse) : 배열의 요소를 하나씩 차례로 살펴보는 과정.

# 25/9/18 강의
## 반복

* 반복 구조(reptition structure) 또는 루프(loop)
    * 어떤 조건이 성립하는 동안 처리(프로그램 명령문 또는 명령어의 집합)를 반복해 실행하는 것.

* While(제어식) 명령문
    * 반복의 대상이 되는 '명령문'을 문법적으로는 '루프 본문' 이라고 함.

* do-while(제어식) 사전 판단 반복
    * **실행 전에 계속 반복 할지**를 판단합니다.
    * 제어식의 평가 값이 0(false)이 아니면 프로그램 명령문을 반복함.

## 다중 루프
* 반복 안에서 다시 반복할 수 있음
* 이런 반복을 루프가 중첩되는 수준에 따라 '이중 루프, 삼중 루프' 라고 함.

## C언어의 불리언(boolean) 처리 방식

* C언어는 불리언 타입이 없음.
* 따라서 false는 0, 그리고 0아닌 모든 값은 true 1로 간주됨.

# 25/9/11 강의
## 알고리즘

## 연산자(operator)

1. 단 항 연산자 : 피연산자 1개  `a++`
2. 2항 연산자 : 피연산자 2개    `a>b`
3. 3항 연산자 : 피연산자 3개    `a?:b:c`

## 식과 식의 평가
* 식(expression): **변수, 상수, 연산자** 등을 사용하여 표현된 관계나 구조를 의미.
* 식의 평가: 식의 값을 알아내는 것을 평가라고 함.

## 알고리즘(Algorithm)
* 어떤 문제를 해결하기 위한 ***논리적인 절차나 방법을 순서대로 기술*** 한 것.
* 주로 ***언어적인 표현 방식*** 을 사용하며, 단계별로 수행해야 할 동작들을 순서대로 나열함.

## 순서도(Flowchart)

* 알고리즘을 그림 형태로 표현한 것.
* 일련의 처리 과정과 흐름을 시각적으로 보여주기 위해 **표준화된 기호** 사용함.
* 알고리즘의 흐름은 위에서 아래 방향으로 전개함.
* 알고리즘(또는 프로그램)이 흐르는 방향은 조건식에 따라 결정됨.

## 관계 연산자와 등가 연산자

* 관계 연산자: 왼쪽과 오른쪽의 피연산자의 대소 관계를 판단.
    * `<, <=, >=, >`
* 등가 연산자: 왼쪽과 오른쪽의 피연산자의 값이 동일한지 판단.
    * `==, =!`(True, False)
---

* 매개변수(Parameta): 함수를 정의할 때 함수에 전달 받은 값을 저장하는 변수

* 인수(Argument): 함수를 사용할 때 함수의 매개변수로 전달할 값.

* 함수를 호출하는 곳에서 argument를 함수에 전달하면, 함수는 전달 받은 인수를 이용해서 함수를 실행한 후 return문으로 결과 값을 호출한 곳으로 보냄.

* return 값의 자료형이 void인 경우 값을 반환하지 않음.

## 세 정수의 대소 관게와 중앙값
* 세 정수의 대소 관계는 **모두 13종류** 이다.
* 이 관계를 정리한 그래프를 **결정 트리(decision Tree)** 라고 한다.

## 세 정수의 중앙값
* 최댓값, 최솟값과는 다르게 중앙값을 찾는 절차는 매우 복잡함.
* 따라서 여러가지 알고리즘을 생각할 수 있다.
* 세 정수의 중앙값을 구하는 절차는 **퀵 정렬(Quick sort)** 를 이용한다.


# 25/9/4 강의

# [문자 크기](#h1에-해당) / [리스트](#리스트)

# 문자 크기

# h1에 해당
## h2에 해당
### h3에 해당
#### h4에 해당
##### h5에 해당
###### h6에 해당

*이텔릭체*

**볼드체**

---
# 리스트
* 언오더드 리스트
* 언
    * 탭
    * 탭
        * 탭
        * 탭
            * 변화없음
- 리스트

1. 오더드 리스트
2.
3.

# 코드 블럭
```c
#include <stdio.h>

int main(){
    printf("Hello World!\n");

    return 0;
}
```

인라인 코드 블럭 예시 : `<br>`

다른 예시: `Ctrl` + `A`

# 외부링크
[구글로 가기](https://google.com "구글 링크")

# [이미지](zhangye-9788010_1280.jpg "이미지 삽입")
