# 최 태웅 (Choi Taeung)
### 202530235

# 25/10/30 강의

## 스택(stack) - 1
* 데이터를 일시적으로 저장하기 위해 사용하는 자료구조.
* 입출력 순서는 후입선출(LIFO, Last In First Out)방식
    - 즉, 가장 나중에 넣은 데이터를 가장 먼저 꺼냄

* 푸시(push): 스택에 데이터를 넣는 작업
* 팝(pop): 데이터를 꺼내는 작업
* 꼭대기(top): 푸시, 팝을 하는 위치
    - 테이블에 겹겹이 쌓은 접시처럼 데이터를 넣는 작업도 꺼내는 작업도 위쪽부터 수행
* 바닥(bottom): 스택의 가장 밑바닥 부분

## 스택 - 2
* 구현 예시
    - 함수를 호출하고 실행할 때 프로그램 내부에서는 스택을 사용
    - 가장 먼저 main함수를 실행, z 함수를 호출함.
    - 호출된 함수 z는 x함수와 y함수를 순서대로 호출.
    - 함수를 호출할 때는 **push**, 함수가 실행 및 종료하고 호출한 원래의 함수로 리턴할때는 종료할 함수를 **pop**함.

    - main -> z -> x의 순서대로 함수 호출.
        - 이때, 스택의 상태는 호출하는 함수의 역순으로 겹겹이 쌓여 있어, 함수 호출이 ***계층 구조***로 이루어짐.
        - 이 상태에서 x함수의 실행이 종료되면 x함수만 **pop**함.

## 스택 만들기 - 1
* 스택 구조체 IntStack
    - 스택으로 사용할 배열을 가라키는 포인터 stk
        - index가 0인 요소를 스택의 바닥(bottom)이라 함.
        - 배열의 메모리 공간 할당은 Initialize 함수로 생성
    - 스택의 최대 용량 max
        - 배열 stk의 요소 개수와 같음
    - 스택 포인터 ptr
        - 스택에 쌓여 있는 데이터의 개수를 나타냄
        - 스택이 비어 있으면 ptr의 값은 0, 가득 차 있으면 max.

## 큐
* 데이터를 일시적으로 쌓아 두기 위한 자료 구조
    - 선입선출 방식.(FIFO)

### 큐 예시
* a 배열의 프런트부터 4개(19, 22, 37, 53)의 데이터가 들어가 있는 모습
* b 24 인큐
    - 리어의 데이터가 저장된 que[3]의 다음 요소 que[4]에 24를 저장
    - 이 처리의 복잡도는 **O(1)**이고 적은 비용으로 구현 가능.
* c 19 디큐
    - 

### 링 버퍼
* 배열의 처음이 끝과 연결되었다고 보는 자료구조
* 프런트: 논리적인 맨 처음 요소의 인덱스
* 리어: 논리적인 맨 끝 요소의 하나 뒤의 인덱스(다음 요소를 인큐할 위치를 미리 지정)
* 변수 프런트와 리어의 값은 인큐와 디큐를 수행함에 따라 변화, 배열 요소를 앞쪽으로 옮기지 않는 큐를 구현할 수 있음.
* 처리의 복잡도는 **O(1)**.

## 정렬 - sorting
* 정렬
    * 핵심 항목(key)의 대소 관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업
    * 키값이 작은 데이터를 앞쪽에 놓으면 오름차순 정렬, 반대로 놓으면 내림차순 정렬.

* 정렬 알고리즘의 안정성
    - 같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지되는 것.

* 정렬 알고리즘의 핵심 요소
    - 교환, 선택, 삽입

### 버블 정렬
* 패스(pass)
    - 이웃한 요소를 비교, 교환하는 작업을 첫 번째 요소까지 계속.
    - 요소의 개수가 n개인 배열에서 n-1 회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동함
    - 이런 일련의 과정(비교, 교환 작업)을 패스라고 함.

* 패스 수행 횟수
    - 두 번째 패스의 비교 횟수는 첫 번째 패스보다 1회적은 n-2회
        - 그 이유는 패스를 1회 수행할 때마다 정렬할 요소가 하나씩 줄어들기 때문.
    
    - 패스를 k회 수행하면 앞쪽의 요소 k개가 정렬
    - 모든 정렬이 끝나려면 n-1회의 패스가 수행되어야함.

* 알고리즘 개선
    - 어떤 시점 이후에 교환이 수행되지 않는다면 그보다 앞쪽의 요소는 이미 정렬 마친 상태라고 생각하면됨.
    - 이미 배열이 정렬을 마친 상태라면 그 이후의 패스는 요소 교환을 하지 않음
    - 즉, 어떤 패스에서 

# 25/10/23 강의

## 검색과 키, 배열 검색

* 주소록 검색
    - 특정 항목에 주목함.
    - 주목하는 항목을 키(key)라고 함.
        * 예시
        1. 국적이 한국인 사람을 찾습니다.
            - 키값과 일치하게 지정 (한국)
        2. 나이가 21세 이상 27세 미만인 사람을 찾습니다.
            - 키값의 구간을 지정 (21세 이상 27세 미만)
        3. 어떤 낱말과 발음이 가장 비슷한 이름의 사람을 찾습니다.
            - 키값과 비슷하도록 지정 (발음이 가장 비슷한 이름)

    - 단순한 정수 값이면 데이터 값을 키 값이라고 생각하나, 키는 데이터의 '일부'다.
    - 하나만 지정, 논리곱이나 논리합을 사용하여 복합해서 지정함.

* 배열 검색 - 공통: 빠른 검색 실행함.
    - 선형 검색 : 무작위로 늘어놓은 데이터 모임
    - 이진 검색 : 일정한 규칙으로 늘어놓은 데이터 모임
    - 해시법 : 추가, 삭제가 자주 일어나는 데이터 모임
        - 체인법 : 같은 해시값의 데이터를 선형 리스트로 연결하는 방법
        - 오픈 주소법: 데이터를 위한 해시값이 충돌할 때 재해시하는 방법

### 선형 검색
* 선형 검색 다루기(1)
    * **선형 검색(linear search)** 또는 **순차 검색(sequential search)**
        - 요소가 **직선 모양으로 늘어선 배열**에서의 검색은 원하는 키값을 갖는 요소를 만날 때까지 **맨 앞부터 순서대로 요소를 검색**.

    * 선형 검색에서 배열 검색의 종료 조건
        1. 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우 **(검색 실패)**
        2. 검색할 값과 같은 요소를 발견한 경우 **(검색 성공)**
        - 배열 요소의 개수가 n개일 때 1,2 조건을 판단하는 횟수는 **평균 n/2 회**다.

* 선형 검색 다루기(2)
    * 요소 개수가 n인 배열 a에서 값이 key인 요소를 검색하는 코드
        1. 배열을 검색할 때 배열 요소의 인덱스를 가리키는 변수는 i
        2. i는 0으로 초기화하고, 요소를 하나 검색할 때마다 while문이 제어하는 루프 본문의 끝에서 증가
        3. 배열 검색 종료 조건 중 어느 하나라도 성립한 경우에는 while 문을 빠져나감.

        ```C
            int i = 0;
            while (1){
                if(i == n)
                    return -1;  //검색실패 
                if(a[i] == key)
                    return 1;   //검색성공
                i++
            }
        ```

* 선형 검색 다루기(3)
    - search 함수는 배열 a의 처음부터 끝까지 n개의 요소를 대상으로 값이 key인 요소를 선형 검색
    - 반환값은 발견한 요소의 인덱스
    - 만약 값이 key인 요소가 여러 개 존재한다면 반환값은 검색 과정에서 처음 발견한 요소의 인덱스
    - 값이 key인 요소가 존재하지 않으면 -1 반환.

    ```C
        int main(void) 
        { 
            int nx, ky;
            puts("선형 검색");
            printf("요소 개수: ");
            scanf("%d",&nx);
            int *x= calloc(nx, sizeof(int)); // 요소의 개수가 nx인 int형 배열 x를 생성 
            for(int i = 0; i < nx; i++) { 
                printf("x[%d]:",i); 
                scanf("%d",&x[i]); 
            } 
            printf("검색값: ");
            scanf("%d",&ky);
            int idx = search(x, nx, ky);// 배열 x의 값이 ky인 요소를 선형 검색
            if(idx ==- 1) 
                puts("검색에 실패했습니다.");
            else 
                printf("%d(은)는 x[%d]에 있습니다. \n", ky, idx);
            free(x); // 배열 x를 해제

            return 0;
        }
    ```

* 선형 검색 다루기(4,5)
    - 선형 검색 구현 (search1.c)

### 보초법검색
* 보초법(sentinel method)
    - 종료 조건을 검사하는 비용을 반으로 줄이는 방법

* 보초법을 이용한 선형 검색
    - 배열의 요소 a[0] ~ a[6]은 원래 데이터
    - 맨 끝 요소 a[7]은 검색하기 전에 준비하는 보초
    - 원하는 값이 원래의 데이터에 존재하지 않아도 보초인 a[7]까지 검색하면 종료조건 2가 성립.
    - 이렇게 하면 원하는 키값을 찾지 못했을 때 종료 조건 1이 없어도 됨.
    - 보초는 반복문에서 종료판단 횟수를 2회에서 1회로 줄이는 역할.

    * **참고** 선형 검색에서 배열 검색의 종료 조건
        1. 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우
        2. 검색할 값과 같은 요소를 발견한 경우.

* 보초법 검색 다루기

### 이진 검색
* 이진 검색
    - 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘
* 이진 검색에서 배열 검색의 종료 조건
    1. 중앙 요소와 key가 일치하는 경우(검색 성공)
    2. 검색 범위가 더 이상 없는 경우(검색 실패)
* 검색에 필요한 비교횟수
    - 검색을 반복할 떄마다 검색 범위가 절반이 되므로 검색에 필요한 비교 횟수의 평균값은 log n
    - 성공한 경우에는 대략 log n - 1회
    - 실패한 경우는 log(n+1)회

### 복잡도
* 복잡도(complexity)
    - 프로그램의 실행 속도는 프로그램이 동작하는 HW나 컴파일러 등의 조건에 따라 달라짐
    - 알고리즘의 성능을 객관적으로 평가하는 기준

* 복잡도의 두 가지 요소
    1. 시간 복잡도: 실행에 필요한 시간을 평가한 것
    2. 공간 복잡도: 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것

* 시간 복잡도와 공간 복잡도
    - 앞 장에서 배운 '소수'를 찾는 프로그램은 알고리즘을 선택할 때 두 복잡도(시간, 공간)의 균형을 생각할 필요성이 있음.

* 선형 검색의 시간 복잡도
    - O(f(n)) + O(g(n)) = O(max(f(n), g(n)))
        - 일반적으로 O(f(n))과 O(g(n))의 복잡도 계산하는 방법.

### 정렬된 배열에서 검색하는 bsearch 함수 알아보기
* bsearch
    - C언어 표준 라이브러리는 다양한 요소의 자료형을 가진 배열에서도 검색 가능한 bsearch 함수를 제공
    - 이진 검색에서 따왔지만, 내부적으로 항상 이진 검색 알고리즘을 사용하지는 않음.

    * 특징
        1. 검색 대상의 배열은 항상 정렬되어 있어야 함
        2. 검색하는 값과 같은 요소가 여러 개 존재하는 경우, 항상 가장 앞쪽에 있는 요소를 찾아내는건 아님.
# 25/10/16(중간고사)

# 25/10/2 강의
## 배열 요소를 역순으로 정리(1)
- 배열 요소를 역순으로 정렬.
    - 왼쪽 요소의 인덱스 ... i
    - 오른쪽 요소의 인덱스 ... n - i - 1

* 두 값의 교환
    - 1: t = x; x값을 t에 보관
    - 2: x = y; y값을 x에 대입
    - 3: y = t; t에 보관한 처음 x값을 y에 대입

## 배열 요소를 역순으로 정리(2)

- 실습 2-7(1)
- swap은 'type형 변수 x, y'의 값을 교환하는 함수 형식의 매크로
- 함수 형식 매크로는 프로그램을 컴파일하는 과정에서 그대로 치환
- ary_reverse 함수는 함수 형식 매크로 swap을 n/2회 호출하여 배열의 요소를 역순으로 정렬. 


## 배열 요소의 최대값 구하기(1)
1. rand함수, srand 함수, time 함수의 선언이 들어 있는 헤더를 포함
2. 난수의 seed(씨앗)를 초기화하기 위해 srand 함수를 호출
3. 난수를 생성하기 위해 rand 함수를 호출

## 기수 변환하기(1)
* 정수 값을 임의의 기수(cardinal number)로 변환하는 알고리즘
    - 10진수 정수를 n진수 정수로 변환할려면
    - 정수를 n으로 나눈 나머지를 구하는 동시에 그 몫에 대해 나눗셈을 반복
    - 이 과정을 몫이 0이 될 때까지 반복
    - 이 과정에서 구한 나머지를 거꾸로 늘어 놓은 숫자가 기수로 변환한 숫자
    - 기수가 10단위를 넘는 경우 0 ~ 9에 이어지는 숫자로 알파벳 문자인 A, B, ...를 사용
    - 16진수는 아래 16개의 문자로 표현되는 수(0,1,2,3,4,5,6,7,8,9,**A,B,C,D,E,F**)

## 기수 변환하기(2)
* 실습 2-8[A](1)
    - 기수 변환을 수행하는 프로그램
    - card_convr함수는 정수 x를 n진수로 변환한 숫자 문자의 정렬을 char형 배열 d에 저장 및 그 자릿수(배열에 저장한 문자 수)를 반환하는 함수.
    - char형의 배열 dchar는 "0123456789ABCDFEFGHIJKLMNOPQRSTUVWXYZ"

## 소수 나열하기(1)
* 소수(prime number)

## 다차원 배열(multidimensional array)
* 배열을 요소로 하는 배열
    * 배열을 자료형으로 하면 2차원 배열이고, 2차원 배열을 자료형으로 하면 3차원 배열

- 1차원 배열: 지금까지 배운 '단일 자료형을 가지는 배열'
- 2차원 배열의 도출
    1. [a] int형 .. int 자료형
    2. [b] int[3]형 ... int를 자료형으로 하는 단일 요소가 3개인 배열
    3. [c] int[4][3]형 ... int를 자료형으로 하는 단일 요소가 3개인 배열을 자형으로 하는 요소 개수가 4개인 배열.

## 구조체(structure)
- 임의의 자료형의 요소를 조합하여 다시 만든 자료구조

* 구조체형과 멤버의 접근
    1. 구조체 선언
        - 구조체에 붙는 이름인 xyz를 구조체 태그라고 함.
        - 구조체를 구성하는 요소를 구조체 멤버라고 함.
    2. 구조체형을 갖는 객체 정의
        - struct xyz 형을 갖는 객체 a를 정의
        - 구조체의 객체 안 멤버는, 연산자를 사용하여 접근
    3. 포인터가 객체를 가리키도록 선언
        - p가 구조체형 객체에 대한 포인터일 때 p가 가리키는 객체의 멤버 x에 접근하는 형식은 연산자를 사용함.

- 구조체 동의어 정의
    1. 구조체는 태그 이름 xyz만으로 구조체 자료형의 이름으로 지정할 수 없음.
    2. 구조체 자료형의 이름은 struct xyz처럼 두 단어로 구성해야함.
    3. typedef 선언을 사용해 짧은 이름으로 다시 만들어 사용할 수 있음.
    4. 이제 하나의 단어 xyz만으로 구조체 자료형의 이름을 나타낼 수 있음.
    5. 이렇게 하면 변수 a와 포인터 p를 간단하게 선언하고 정의할 수 있음.
    

# 25/9/25 강의

## 배열(array)

* 배열은 같은 자료형의 변수로 이루어진 요소가 모여 직선 모양으로 줄지어 있는 자료구조.
* 네모 칸 안에 쓰인 숫자나 문자가 요소 값이고, 네모 칸의 왼쪽 또는 위쪽에 쓰인 작은 숫자가 인덱스 값.(index)

## 배열 이름[인덱스]
* 배열의 개별 요소에 접근할 때 인덱스 식(subscript expression)을 사용.
* 배열의 요소 값을 초기화하며, 배열을 선언하는 프로그램.
* 각 요소를 처음부터 순서대로 쉼표(,)로 구분하여 줄지어 놓고 {}로 둘러쌈으로써 배열 요소 초기화.
* sizeof(a)로 전체 배열이 할당된 메모리 크기를 구하고, sizeof(a[0])로 첫 번째 요소가 할당된 메모리 크기를 구한 다음, 전체 배열 크기를 첫 요소 크기로 나눈 몫이 요소 개수가 됨.

### 수식
`sizeof(배열명)` / `sizeof(자료형)`
* 자료형에는 int, char, double 등을 사용.

### 메모리 할당 
* calloc, malloc 함수는 힙(heap)이라는 특별한 '빈 공간(free space)'에 기억 장소 확보함.
    * 사용 할 떄는 헤더 `#include <stdlib.h>` 사용

* calloc(clear and allocation): 메모리를 할당하고 0으로 초기화.
1.일반적으로 메모리 1개를 설정하기 위해서 calloc 함수를 사용하지 않음.
2.배열처럼 여러 개 요소를 할당, 초기값을 0으로 맞추고 싶을 때 유용.
3.배열은 정적 메모리 할당이고, calloc 함수는 동적 메모리 할당이다.
-> 배열은 컴파일할 때 크기가 정해져야 하지만, 런타임에 원하는 크기만큼 할당할 수 있음.
-> 즉, 가변크기 할당 가능.

* malloc(memory allocation): 메모리를 할당만 하고 초기화는 X. (가비지)
* heap : 완전 이진 트리의 한 종류로 최대힙과 최소힙이 존재.

#### 메모리 해제
* 확보한 메모리가 불필요하면 그 공간을 해제해야 하는데 이를 위해 제공되는 함수가 free함수다.
    * 프로그램을 실행하는 도중에도 원하는 시점에 제거할 수 있음.
* `free()`는 *동적으로* **할당된 메모리를 해제하는 역할**을 하는 것.

## 스택 메모리
##### 스택(stack) 메모리는 자료구조의 스택 (FIFO)과는 다름.
- 스택 메모리는 메모리 관리 방식이지 메모리 접근 방식이 아님.
- 그러므로 FIFO를 따르는 것이 아니라 index를 통해 입출력을 함.

## 배열 요소의 최댓값 구하기 - maxof()
- maxof는 내장 함수가 아님.
- 주사(traverse) : 배열의 요소를 하나씩 차례로 살펴보는 과정.

# 25/9/18 강의
## 반복

* 반복 구조(reptition structure) 또는 루프(loop)
    * 어떤 조건이 성립하는 동안 처리(프로그램 명령문 또는 명령어의 집합)를 반복해 실행하는 것.

* While(제어식) 명령문
    * 반복의 대상이 되는 '명령문'을 문법적으로는 '루프 본문' 이라고 함.

* do-while(제어식) 사전 판단 반복
    * **실행 전에 계속 반복 할지**를 판단합니다.
    * 제어식의 평가 값이 0(false)이 아니면 프로그램 명령문을 반복함.

## 다중 루프
* 반복 안에서 다시 반복할 수 있음
* 이런 반복을 루프가 중첩되는 수준에 따라 '이중 루프, 삼중 루프' 라고 함.

## C언어의 불리언(boolean) 처리 방식

* C언어는 불리언 타입이 없음.
* 따라서 false는 0, 그리고 0아닌 모든 값은 true 1로 간주됨.

# 25/9/11 강의
## 알고리즘

## 연산자(operator)

1. 단 항 연산자 : 피연산자 1개  `a++`
2. 2항 연산자 : 피연산자 2개    `a>b`
3. 3항 연산자 : 피연산자 3개    `a?:b:c`

## 식과 식의 평가
* 식(expression): **변수, 상수, 연산자** 등을 사용하여 표현된 관계나 구조를 의미.
* 식의 평가: 식의 값을 알아내는 것을 평가라고 함.

## 알고리즘(Algorithm)
* 어떤 문제를 해결하기 위한 ***논리적인 절차나 방법을 순서대로 기술*** 한 것.
* 주로 ***언어적인 표현 방식*** 을 사용하며, 단계별로 수행해야 할 동작들을 순서대로 나열함.

## 순서도(Flowchart)

* 알고리즘을 그림 형태로 표현한 것.
* 일련의 처리 과정과 흐름을 시각적으로 보여주기 위해 **표준화된 기호** 사용함.
* 알고리즘의 흐름은 위에서 아래 방향으로 전개함.
* 알고리즘(또는 프로그램)이 흐르는 방향은 조건식에 따라 결정됨.

## 관계 연산자와 등가 연산자

* 관계 연산자: 왼쪽과 오른쪽의 피연산자의 대소 관계를 판단.
    * `<, <=, >=, >`
* 등가 연산자: 왼쪽과 오른쪽의 피연산자의 값이 동일한지 판단.
    * `==, =!`(True, False)
---

* 매개변수(Parameta): 함수를 정의할 때 함수에 전달 받은 값을 저장하는 변수

* 인수(Argument): 함수를 사용할 때 함수의 매개변수로 전달할 값.

* 함수를 호출하는 곳에서 argument를 함수에 전달하면, 함수는 전달 받은 인수를 이용해서 함수를 실행한 후 return문으로 결과 값을 호출한 곳으로 보냄.

* return 값의 자료형이 void인 경우 값을 반환하지 않음.

## 세 정수의 대소 관게와 중앙값
* 세 정수의 대소 관계는 **모두 13종류** 이다.
* 이 관계를 정리한 그래프를 **결정 트리(decision Tree)** 라고 한다.

## 세 정수의 중앙값
* 최댓값, 최솟값과는 다르게 중앙값을 찾는 절차는 매우 복잡함.
* 따라서 여러가지 알고리즘을 생각할 수 있다.
* 세 정수의 중앙값을 구하는 절차는 **퀵 정렬(Quick sort)** 를 이용한다.


# 25/9/4 강의

# [문자 크기](#h1에-해당) / [리스트](#리스트)

# 문자 크기

# h1에 해당
## h2에 해당
### h3에 해당
#### h4에 해당
##### h5에 해당
###### h6에 해당

*이텔릭체*

**볼드체**

---
# 리스트
* 언오더드 리스트
* 언
    * 탭
    * 탭
        * 탭
        * 탭
            * 변화없음
- 리스트

1. 오더드 리스트
2.
3.

# 코드 블럭
```c
#include <stdio.h>

int main(){
    printf("Hello World!\n");

    return 0;
}
```

인라인 코드 블럭 예시 : `<br>`

다른 예시: `Ctrl` + `A`

# 외부링크
[구글로 가기](https://google.com "구글 링크")

# [이미지](zhangye-9788010_1280.jpg "이미지 삽입")
